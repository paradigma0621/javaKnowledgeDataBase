* doAnswer
** Caso onde retorna lista de Longs
class BusinessUnitWorkplaceRepositoryImplTest extends TestUnitHelper {
    @Mock
    private NamedParameterJdbcTemplate namedParameter;
    @InjectMocks
    private BusinessUnitWorkplaceRepositoryImpl repository;

    @Test
    void deveRetornarOptionalDeWorkplaceIds() {
        //Given
        var queryParameterDto = returnQueryParameterDto();
        var workplaceId = faker.number().randomNumber();

        var expected = List.of(workplaceId);
        doAnswer(new Answer<List<Long>>() {
            @Override
            public List<Long> answer(InvocationOnMock invocation) throws Throwable {
                var result = mock(ResultSet.class);
                when(result.getLong(ID)).thenReturn(workplaceId);
                RowMapper<Long> rowMapper = invocation.getArgument(2);
                return List.of(rowMapper.mapRow(result, 0));
            }
        }).when(namedParameter)
                .query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        // When
        var actual = repository.findBusinessUnitWorkplaceIds(queryParameterDto);
        // Then
        assertThat(actual.get()).containsExactlyElementsOf(expected);
        verify(namedParameter, times(1))
                .query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
    }

    private QueryParameterDto returnQueryParameterDto() {
        return new QueryParameterDto("", new MapSqlParameterSource());
    }
** Caso onde retorna só um Dto (não collection)
//A diferença em relação à quando retorna Collection está no ResultSetExtractor.class (nesse caso abaixo também no when(result.next()).thenReturn(true);, pois na classe de repository tinha a verificação:
//return namedParameterJdbcTemplate.query(queryParameterDto.sql(), queryParameterDto.parameter(), result -> {
//            if (result.next()) {

class ScheduleRepositoryImplTest extends TestUnitHelper {
    @Mock
    private NamedParameterJdbcTemplate namedParameter;
    @InjectMocks
    private ScheduleRepositoryImpl repository;

    @Test
    void deveRetornarOptionalDeScheduleDto() {
        var queryParameterDto = returnQueryParameterDto();
        var rotationCode = faker.number().randomNumber();
        var scheduleName = faker.lorem().word();
        var scheduleNameExpected = scheduleName + "/" + rotationCode;
        var rotationBaseDate = LocalDate.now();
        var expected = new ScheduleDto(scheduleNameExpected, rotationCode, rotationBaseDate);

        doAnswer(invocation -> {
            var result = mock(ResultSet.class);
            when(result.next()).thenReturn(true);
            when(result.getLong(ROTATION_CODE)).thenReturn(rotationCode);
            when(result.getString(SCHEDULE_NAME)).thenReturn(scheduleName);
            when(result.getDate(ROTATION_BASE_DATE)).thenReturn(Date.valueOf(rotationBaseDate));
            ResultSetExtractor<ScheduleDto> rse = invocation.getArgument(2);
            return rse.extractData(result);
        }).when(namedParameter)
                .query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));

        var actual = repository.getScheduleRepositoryDto(queryParameterDto);

        assertThat(actual.get()).isEqualTo(expected);
        verify(namedParameter, times(1))
                .query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));
    }

    private QueryParameterDto returnQueryParameterDto() {
        return new QueryParameterDto("", new MapSqlParameterSource());
    }
}

** Caso onde retorna uma Collection só que de não Wrapper, mas sim de um objeto processado
*** repository
    @Autowired
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    public Optional<List<TemplateTypeEnum>> getPersonTemplates(QueryParameterDto queryParameterDto) {
        return Optional.of(
                namedParameterJdbcTemplate.query(queryParameterDto.sql(), queryParameterDto.parameter(), (result, rowNum) ->
                        TemplateTypeEnum.getById(result.getLong(TEMPLATE_TYPE_ID))
                )
        );
    }
*** test
    @Test
    void deveRetornarOptionalDeTemplateDtos() {
        //Given
        var queryParameterDto = returnQueryParameterDto();

        var expected = List.of(TemplateTypeEnum.FINGERPRINT);

        doAnswer(new Answer<List<TemplateTypeEnum>>() {
            @Override
            public List<TemplateTypeEnum> answer(InvocationOnMock invocation) throws Throwable {
                var result = mock(ResultSet.class);
                when(result.getLong(TEMPLATE_TYPE_ID)).thenReturn(TemplateTypeEnum.FINGERPRINT.getId());
                RowMapper<TemplateTypeEnum> rowMapper = invocation.getArgument(2);
                return List.of(rowMapper.mapRow(result, 0));
            }
        }).when(namedParameter)
                .query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));

        // When
        var actual = repository.getPersonTemplates(queryParameterDto);

        // Then
        assertThat(actual.get()).containsExactlyElementsOf(expected);
        verify(namedParameter, times(1))
                .query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
    }

** Caso onde retorna um String, usando @Override public Optional<String> answer(InvocationOnMock invocation) throws Throwable {
*** repository
public class ShiftRepositoryImpl implements ShiftRepository {

    @Autowired
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    public Optional<String> getShiftName(QueryParameterDto queryParameterDto) {
        return namedParameterJdbcTemplate.query(queryParameterDto.sql(), queryParameterDto.parameter(), result -> {
            if (result.next())
                return Optional.of(result.getString(SHIFT_NAME));

            return Optional.empty();
        });
    }
}

*** test
class ShiftRepositoryImplTest extends TestUnitHelper {
    @Mock
    private NamedParameterJdbcTemplate namedParameter;
    @InjectMocks
    private ShiftRepositoryImpl repository;

    @Test
    void deveRetornarOptionalDeNomesDeHorarios() {
        //Given
        var queryParameterDto = returnQueryParameterDto();
        var shiftName = faker.lorem().characters();

        var expected = shiftName;

        doAnswer(new Answer<Optional<String>>() {
            @Override
            public Optional<String> answer(InvocationOnMock invocation) throws Throwable {
                var result = mock(ResultSet.class);
                when(result.getString(SHIFT_NAME)).thenReturn(shiftName);
                when(result.next()).thenReturn(true);
                ResultSetExtractor<Optional<String>> rse = invocation.getArgument(2);
                return rse.extractData(result);
            }
        }).when(namedParameter)
                .query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));
        // When
        var actual = repository.getShiftName(queryParameterDto);
        // Then
        assertThat(actual.get()).isEqualTo(expected);
        verify(namedParameter, times(1))
                .query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));
    }

    private QueryParameterDto returnQueryParameterDto() {
        return new QueryParameterDto("", new MapSqlParameterSource());
    }

}

** Caso onde retorna List<Dto> - mquando a query termina em: queryParameterDto.parameter(), (result, rowNum) -> modo 1
*** repository
    @Override
    public Optional<List<PersonLoadDto>> findReplacements(QueryParameterDto queryParameterDto) {
        return Optional.of(
                namedParameterJdbcTemplate.query(queryParameterDto.sql(), queryParameterDto.parameter(), (result, rowNum) ->
                        new PersonLoadDto(
                                result.getLong(ID),
                                result.getString(NAME),
                                PersonConditionEnum.valueOf(result.getString(PERSON_CONDITION)),
                                result.getLong(REPLACEMENT_ID),
                                result.getString(ENROLMENT))
                ));
    } 
*** test
    @Test
    void deveRetornarOptionalDePersonLoadDtoAoBuscarCoberturas() {
        //Given
        var queryParameterDto = returnQueryParameterDto();
        var personId = faker.number().randomNumber();
        var personName = faker.name().fullName();
        var personCondition = PersonConditionEnum.REPLACING_WORKPLACE;
        var replacementId = faker.number().randomNumber();
        var enrolment = faker.lorem().word();

        var expected = new PersonLoadDto(
                personId,
                personName,
                personCondition,
                replacementId,
                enrolment
        );

        doAnswer(new Answer<List<PersonLoadDto>>() {
            @Override
            public List<PersonLoadDto> answer(InvocationOnMock invocation) throws Throwable {
                var result = mock(ResultSet.class);
                when(result.getLong(ID)).thenReturn(personId);
                when(result.getString(NAME)).thenReturn(personName);
                when(result.getLong(REPLACEMENT_ID)).thenReturn(replacementId);
                when(result.getString(PERSON_CONDITION)).thenReturn(personCondition.name());
                when(result.getString(ENROLMENT)).thenReturn(enrolment);
                RowMapper<PersonLoadDto> rowMapper = invocation.getArgument(2);
                return List.of(rowMapper.mapRow(result, 1));
            }
        }).when(namedParameter).query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));

        // When
        var actual = repository.findReplacements(queryParameterDto);

        // Then
        assertThat(actual.get().get(0)).isEqualTo(expected);
        verify(namedParameter, times(1))
                .query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
    }

** Caso onde retorna List<Dto> - mquando a query termina em: queryParameterDto.parameter(), (result, rowNum) -> modo 2
*** repository

    @Override
    public Optional<List<PersonLoadDto>> findReplacements(QueryParameterDto queryParameterDto) {
        return Optional.of(
                namedParameterJdbcTemplate.query(queryParameterDto.sql(), queryParameterDto.parameter(), (result, rowNum) ->
                        new PersonLoadDto(
                                result.getLong(ID),
                                result.getString(NAME),
                                PersonConditionEnum.valueOf(result.getString(PERSON_CONDITION)),
                                result.getLong(REPLACEMENT_ID),
                                result.getString(ENROLMENT))
                ));
    } 
*** test
@Test
    public void testFindReplacements() throws SQLException {
        ResultSet result = mock(ResultSet.class);
        when(result.getLong(ID)).thenReturn(1L);
        when(result.getString(NAME)).thenReturn("Test Name");
        when(result.getString(PERSON_CONDITION)).thenReturn(PersonConditionEnum.REPLACING_WORKPLACE.name());
        when(result.getLong(REPLACEMENT_ID)).thenReturn(2L);
        when(result.getString(ENROLMENT)).thenReturn("Test Enrolment");

        var queryParameterDto = returnQueryParameterDto();

        when(namedParameter.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenAnswer(invocation -> {
                    RowMapper<PersonLoadDto> rowMapper = invocation.getArgument(2);
                    return Arrays.asList(rowMapper.mapRow(result, 1));
                });

        Optional<List<PersonLoadDto>> replacements = repository.findReplacements(queryParameterDto);

        assertTrue(replacements.isPresent());
        assertEquals(1, replacements.get().size());
        assertEquals("Test Name", replacements.get().get(0).getName());
    }

        private QueryParameterDto returnQueryParameterDto() {
        return new QueryParameterDto("", new MapSqlParameterSource());
    }
** Caso de queryForObject 1
*** repository
    @Override
    public Optional<Long> findTotalReplacementWorkplace(QueryParameterDto queryParameteDto) {
        return Optional.ofNullable(
                namedParameterJdbcTemplate
                        .queryForObject(queryParameteDto.sql(), queryParameteDto.parameter(), Long.class));
    }
*** test
    @Test
    public void deveRetornarNumeroTotalDeCoberturasDePostoNoPosto() {
        QueryParameterDto queryParameterDto = returnQueryParameterDto();
        var expected = 10L;

        when(namedParameter.queryForObject(queryParameterDto.sql(), queryParameterDto.parameter(), Long.class))
                .thenReturn(expected);

        Optional<Long> actual = repository.findTotalReplacementWorkplace(queryParameterDto);

        assertThat(actual).isPresent();
        assertThat(actual.get()).isEqualTo(expected);
//obs: ver nesse documento o caso ** Caso de queryForObject - caso 3 (Core) - detalhe que nesse faço tb o teste do verify()
    }

** Caso de queryForObject - caso 2 
*** repository (com chamada de private countElements())
  	@Override
	public Page<ReplacementReasonDto> findByActives(Pageable pageable) {
		Long customerId = SecurityUtil.getCustomerOrThrowException().getId();
		MapSqlParameterSource namedParameters = new MapSqlParameterSource().addValue("customerId", customerId);

		List<ReplacementReasonDto> replacementReasonDtos = findReplacementReasonDtos(pageable, namedParameters);
		Long totalElements = countElements(namedParameters);

		return new PageImpl<>(new ArrayList<>(replacementReasonDtos), pageable, totalElements);
	}
*** test

        Long expectedNumberElements = 1L;

        when(namedParameter.queryForObject(anyString(), any(MapSqlParameterSource.class), eq(Long.class)))  // O detalhe está no eq(Long.class)
                .thenReturn(expectedNumberElements);
//obs: ver nesse documento o caso ** Caso de queryForObject - caso 3 (Core) - detalhe que nesse faço tb o teste do verify()
** Caso de queryForObject - caso 3 (Core) - detalhe que nesse faço tb o teste do verify()
*** repository
@Repository
public class OPDFindObjectRepository {

    @Autowired
    protected NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    public String findStringResult(OPDQueryParameterDto queryParameterDto) {
        try {
            return Optional.of(namedParameterJdbcTemplate.queryForObject(
                    queryParameterDto.getSql(),
                    queryParameterDto.getParameter(),
                    String.class)).orElse("");
        } catch (EmptyResultDataAccessException e) {
            return "";
        }
    }
	
*** test
@Test
    public void deveRetornarString() {
        OPDQueryParameterDto queryParameterDto = returnQueryParameterDto();
        String expected = "WORKPLACE_BOOK";

        when(namedParameterJdbcTemplate.queryForObject(queryParameterDto.getSql(),
                                                       queryParameterDto.getParameter(),
                                                       String.class))
                .thenReturn(expected);

        String actual = repository.findStringResult(queryParameterDto);

        assertEquals(expected, actual);
        verify(namedParameterJdbcTemplate, times(1)).queryForObject(queryParameterDto.getSql(),
                                                        queryParameterDto.getParameter(), String.class);
    }
** Caso de queryForObject - caso 4 (Core) - detalhe que nesse faço tb o teste do verify() do .queryForObject(
*** repository
public Page<TaskDto> findTaskStageByFilterPageable(final ControlFilterDto filter, final Pageable pageable) {
        final MapSqlParameterSource parameters = buildQueryParametersToFindTaskStage(filter);
        final String query = buildTaskStageQueryToFindTaskStages(filter, pageable);
        final String countQuery = buildCountQueryToFindTaskStages(filter);

        Long total = namedParameterJdbcTemplate.queryForObject(countQuery, parameters, Long.class);
        List<TaskDto> taskDtoList = namedParameterJdbcTemplate.query(query, parameters, this::mapTaskDtoToFindTaskStages);

        return new PageImpl<>(taskDtoList, pageable, total);
    }
*** test
    @Test
    void deveRetornarListaComDtoDeMarcacoesDeTempoEStatusRelativaAoDesenrolarDaTask() throws SQLException {
        ControlFilterDto filter = new ControlFilterDto();
        Pageable pageable = new PageRequest(0,10);
        TaskDto expected = getTaskDtoExample();

        ResultSet resultSet = mock(ResultSet.class);
        setWhensForTasksResultSet(resultSet);

        ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);

        when(namedParameterJdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), rowMapperCaptor.capture()))
                .thenAnswer(invocation -> {
                    RowMapper<TaskDto> rowMapper = invocation.getArgumentAt(2, RowMapper.class);
                    return Arrays.asList(rowMapper.mapRow(resultSet, 1));
                });

        Long expectedNumberElements = 1L;
        when(namedParameterJdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), eq(Long.class)))
                .thenReturn(expectedNumberElements);

        Page<TaskDto> actual = repository.findTaskStageByFilterPageable(filter, pageable);

        assertThat(actual).containsExactly(expected);
        verify(namedParameterJdbcTemplate, times(1)).query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        verify(namedParameterJdbcTemplate, times(1)).queryForObject(anyString(), any(MapSqlParameterSource.class), eq(Long.class));  //****** O detalhe é esse, ond uso eq(Long.class)
    }
** Caso de queryForObject - caso 5 (Core) - enxuto
*** repository

    @Override
    public Long findNumberQuestionsJustifiedAndExpiredByTaskIds(List<Long> taskIdsJustifiedAndExpired,
                                                                FilterParamDto filterParamDto) {
        if (taskIdsJustifiedAndExpired.isEmpty())
            return 0L;

        StringBuilder query = new StringBuilder();
        applyFindTotalQuestionsForJustifiedAndExpiredOperationalTasks(query);

        MapSqlParameterSource parameter = new MapSqlParameterSource();
        parameter.addValue("task_ids", taskIdsJustifiedAndExpired, Types.INTEGER);
        parameter.addValue("finish_date", filterParamDto.getFinishDate().atTime(LocalTime.MAX), Types.TIMESTAMP);

        return namedParameterJdbcTemplate.queryForObject(query.toString(), parameter, Long.class);
    }
*** test
    @Test
    public void deveRetornarNumeroTotalDeQuestoesParaTarefasJustificadasEExpiradas() {
        List<Long> taskIdsJustifiedAndExpired = Collections.singletonList(1L);
        FilterParamDto filterParamDto = new FilterParamDto();
        Long expected = 10L;

        when(namedParameterJdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), eq(Long.class)))
                .thenReturn(expected);

        Long actual = repository.findNumberQuestionsJustifiedAndExpiredByTaskIds(taskIdsJustifiedAndExpired, filterParamDto);

        assertEquals(expected, actual);
		verify(namedParameterJdbcTemplate, times(1)).queryForObject(anyString(), any(SqlParameterSource.class), eq(Long.class));
    }

** Caso de queryForList - Caso 1 (Core)
*** repository

    public List<Long> getTasksPartialJustifiedQuestionsIds(FilterParamDto filterParamDto, List<Long> taskIdsPartialJustified) {
        if (taskIdsPartialJustified.isEmpty())
            return new ArrayList<>();

        MapSqlParameterSource parameterSource =  new MapSqlParameterSource();
        parameterSource.addValue("task_ids", taskIdsPartialJustified, Types.INTEGER);
        parameterSource.addValue("finish_date", filterParamDto.getFinishDate().atTime(LocalTime.MAX), Types.TIMESTAMP);

        StringBuilder query = new StringBuilder();
        findQuestionsForPartialJustifiedTasks(query);

        return namedParameterJdbcTemplate.queryForList(query.toString(), parameterSource, Long.class);
		verify(namedParameterJdbcTemplate, times(1)).queryForList(anyString(), any(SqlParameterSource.class), eq(Long.class));
    }
*** test

    @Test
    public void deveRetornarListaDeIdsDeQuestoesParcialmenteJustificadas() {
        FilterParamDto filterParamDto = new FilterParamDto();
        List<Long> expected = Arrays.asList(1L, 2L, 3L);
        List<Long> taskIdsPartialJustified = Arrays.asList(1L, 2L, 3L, 4L, 5L);

        when(namedParameterJdbcTemplate.queryForList(anyString(), any(SqlParameterSource.class), eq(Long.class)))
                .thenReturn(expected);

        List<Long>  actual = repository.getTasksPartialJustifiedQuestionsIds(filterParamDto, taskIdsPartialJustified);

        assertEquals(expected, actual);
    }
** Caso onde usa query via jdbcTemplate e (rs ->  { ... } ==> RowCallbackHandler)
*** code
    public Page<TaskDto> findPageableCreatedByFilter(TaskDto dto, ControlFilterDto filter, Pageable pageable) {
        String registerDate = NextiUtil.formatDate(dto.getRegisterDate(), "yyyy-MM-dd");
        Long customerId = SecurityUtil.getCustomerOrThrowException().getId();

        StringBuilder query = new StringBuilder();
        query.append(" SELECT  t.id                 AS task_id, ");
        query.append("         ch.name              AS checklist_name, ");
        query.append("         ch.id                AS checklist_id, ");
        query.append("         wor.id               AS workplace_id, ");
        query.append("         wor.name             AS workplace_name, ");
        query.append("         t.task_type_id       AS task_type_id, ");
        query.append("         t.external_place     AS task_external_place, ");
        query.append("         t.register_date     AS register_date, ");
        query.append("         ua.id                AS user_account_id, ");
        query.append("         ua.name              AS user_account_name ");
        query.append(" FROM task t ");
        query.append(" INNER JOIN user_account ua ON ua.id = t.user_account_id ");
        query.append(" LEFT JOIN checklist ch ON ch.id = t.checklist_id AND ch.customer_id = ").append(customerId);
        query.append(" LEFT JOIN workplace wor ON wor.id = t.workplace_id AND wor.customer_id = ").append(customerId);
        query.append(" LEFT JOIN task_stage ts ON ts.task_id = t.id ");

        if (!NextiUtil.arrayIsEmpty(dto.getAreaIds())) {
            query.append(" LEFT JOIN area_workplace aw ON aw.workplace_id  = wor.id  ");
            query.append(" LEFT JOIN area_client ac ON ac.client_id  = wor.client_id  ");
        }

        query.append(" WHERE t.customer_id = ").append(customerId);
        query.append(" AND t.register_date = '").append(registerDate).append("' ");

        taskStagesFilterPopulate(dto, query);

        query.append(" AND ts.id IS NULL ");
        query.append(" ORDER BY t.register_date ASC ");
        query.append(NextiUtil.createQueryPagination(pageable));

        StringBuilder count = new StringBuilder();
        count.append(" SELECT   count(t.id) ");
        count.append(" FROM task t ");
        count.append(" INNER JOIN user_account ua ON ua.id = t.user_account_id ");
        count.append(" LEFT JOIN checklist ch ON ch.id = t.checklist_id AND ch.customer_id = ").append(customerId);
        count.append(" LEFT JOIN workplace wor ON wor.id = t.workplace_id AND wor.customer_id = ").append(customerId);
        count.append(" LEFT JOIN task_stage ts ON ts.task_id = t.id ");

        if (!NextiUtil.arrayIsEmpty(dto.getAreaIds())) {
            count.append(" LEFT JOIN area_workplace aw ON aw.workplace_id  = wor.id  ");
            count.append(" LEFT JOIN area_client ac ON ac.client_id  = wor.client_id  ");
        }

        count.append(" WHERE t.customer_id = ").append(customerId);
        count.append(" AND t.register_date = '").append(registerDate).append("' ");

        taskStagesFilterPopulate(dto, count);

        count.append(" AND ts.id IS NULL ");

        Long total = jdbcTemplate.queryForObject(count.toString(), Long.class);

        List<TaskDto> taskDtoList = new ArrayList<>();
        jdbcTemplate.query(query.toString(), rs ->{
            TaskDto taskDto = new TaskDto();
            taskDto.setId(rs.getLong("task_id"));
            taskDto.setChecklistName(rs.getString("checklist_name"));
            taskDto.setChecklistId(rs.getLong("checklist_id"));
            taskDto.setWorkplaceId(rs.getLong("workplace_id"));
            taskDto.setWorkplaceName(rs.getString("workplace_name") != null ? rs.getString("workplace_name") : rs.getString("task_external_place"));
            taskDto.setTaskTypeId(rs.getLong("task_type_id"));
            taskDto.setUserAccountId(rs.getLong("user_account_id"));
            taskDto.setUserAccountName(rs.getString("user_account_name"));
            taskDto.setRegisterDate(rs.getDate("register_date"));
            taskDtoList.add(taskDto);
        });

        return new PageImpl<>(taskDtoList, pageable, total);
    }

*** test
    @Test
    void deveRetornarPageComTaskDtoDeDetalhesDeTarefasDoTipoARealizar() throws SQLException {
        ControlFilterDto filter = new ControlFilterDto();
        TaskDto taskDto = new TaskDto();
        Pageable pageable = new PageRequest(0,10);
        TaskDto expected = getTaskDtoExampleCreatedType();

        ResultSet resultSet = mock(ResultSet.class);
        setWhensForTasksCreatedResultSet(resultSet);

        doAnswer(invocation -> {
            RowCallbackHandler rch = invocation.getArgumentAt(1, RowCallbackHandler.class);
            rch.processRow(resultSet);
            return null;
        }).when(jdbcTemplate)
                .query(anyString(), any(RowCallbackHandler.class));

        Long expectedNumberElements = 1L;
        when(jdbcTemplate.queryForObject(anyString(), eq(Long.class)))
                .thenReturn(expectedNumberElements);

        Page<TaskDto> actual = repository.findPageableCreatedByFilter(taskDto, filter, pageable);

        assertThat(actual).containsExactly(expected);
        verify(jdbcTemplate, times(1)).query(anyString(), any(RowCallbackHandler.class));
        verify(jdbcTemplate, times(1)).queryForObject(anyString(), eq(Long.class));
    }

** Caso de query aplicado no Report (com  nextiControlDtoMapper.mapRowToTasks...)
*** code

    @Override
    public List<TaskStageDto> findTaskStageTypesAndDates(List<Long> tasksIds) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("tasks_ids", tasksIds, Types.INTEGER);

        final String query = buildFindTasksStageDates();

        return readReplicaNamedParameterJdbcTemplate.query(
                query,
                parameters,
                (rs, rowNum) -> nextiControlDtoMapper.mapRowToTasksStageTypesAndDates(rs)
        );
    }

    public TaskStageDto mapRowToTasksStageTypesAndDates(ResultSet rs) throws SQLException {
        TaskStageDto dto = new TaskStageDto();
        dto.setTaskId(rs.getLong("task_id"));
        dto.setStageDate(rs.getTimestamp("stage_date"));
        dto.setTaskStageTypeId(rs.getLong("task_stage_type_id"));
        return dto;
    }

*** test
    @Test
    void deveRetornarListaComDtoDeMarcacoesDeTempoEStatusRelativaAoDesenrolarDaTask() throws SQLException {
        List<Long> taskIds = Collections.singletonList(123L);
        TaskStageDto expected = getTaskStagesDtoExample();

        ResultSet resultSet = mock(ResultSet.class);
        setWhensForTasksStagesResultSet(resultSet);

        ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);

        when(namedParameter.query(anyString(), any(MapSqlParameterSource.class), rowMapperCaptor.capture()))
                .thenAnswer(invocation -> {
                    RowMapper<TaskStageDto> rowMapper = invocation.getArgumentAt(2, RowMapper.class);
                    return Arrays.asList(rowMapper.mapRow(resultSet, 1));
                });

        List<TaskStageDto> actual = repository.findTaskStageTypesAndDates(taskIds);

        assertThat(actual).containsExactly(expected);
        verify(namedParameter, times(1)).query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
    }

    private static TaskStageDto getTaskStagesDtoExample() {
        TaskStageDto example = new TaskStageDto();
        example.setTaskId(12L);
        example.setStageDate(new Timestamp(12312312312L));
        example.setTaskStageTypeId(Long.valueOf(TaskStageEnum.MOVABLE_FINISH.getId()));
        return example;
    }

    private void setWhensForTasksStagesResultSet(ResultSet resultSet) throws SQLException {
        when(resultSet.getLong("task_id")).thenReturn(12L);
        when(resultSet.getTimestamp("stage_date")).thenReturn(new Timestamp(12312312312L));
        when(resultSet.getLong("task_stage_type_id")).thenReturn(Long.valueOf(TaskStageEnum.MOVABLE_FINISH.getId()));
    }
** Outro caso do report para o qual consegui fazendo implementação usando RowCallbackHandler.class - ele fazia a montagem do retorno usando ", rs -> { ...(popula)... }
*** classe repository dao/PersonDaoImpl.java - método: findAllPersonsById
@Override
	public List<PersonDto> findAllPersonsById(List<Long> personIds, Long customerId) {

		if (Objects.isNull(personIds) || personIds.isEmpty()) {
			return Collections.emptyList();
		}

		StringBuilder sql = new StringBuilder(" select ");
		List<PersonDto> personDtoList = new ArrayList<>();
		sql.append(" p.id as id, ")
				.append("p.workplace_id as workplaceId")
				.append(" from person p ")
				.append(" where p.customer_id = ")
				.append(customerId).append(" and p.id in (")
				.append(convertArrayInStringForQueryIn(personIds))
				.append((") and (p.removed is null or p.removed = 0)"));

		readReplicaNamedParameterJdbcTemplate.query(sql.toString(), rs -> {
			PersonDto personDto = new PersonDto();
			personDto.setId(rs.getLong("id"));
			personDto.setWorkplaceId(rs.getLong("workplaceId"));
			personDtoList.add(personDto);
		});

		return personDtoList;
	}
*** class teste
    @Test
    void deveRetornarListaComDtoDeMarcacoesDeTempoEStatusRelativaAoDesenrolarDaTask() throws SQLException {
        List<Long> personIds = Collections.singletonList(123L);
        PersonDto expected = getPersonDaoExample();

        doAnswer(invocation -> {
            RowCallbackHandler handler = invocation.getArgumentAt(1, RowCallbackHandler.class);

            ResultSet resultSet = mock(ResultSet.class);

            when(resultSet.getLong("id")).thenReturn(expected.getId());
            when(resultSet.getLong("workplaceId")).thenReturn(expected.getWorkplaceId());

            handler.processRow(resultSet);

            return null;
        }).when(readReplicaNamedParameterJdbcTemplate).query(anyString(), any(RowCallbackHandler.class));


        List<PersonDto> actual = personDao.findAllPersonsById(personIds, 1L);

        assertThat(actual).containsExactly(expected);
		verify(readReplicaNamedParameterJdbcTemplate, times(1)).query(anyString(), any(RowCallbackHandler.class));
    }

    private static PersonDto getPersonDaoExample() {
        PersonDto example = new PersonDto();
        example.setId(123L);
        example.setWorkplaceId(456L);
        return example;
    }

    private void setWhensForPersonResultSet(ResultSet resultSet) throws SQLException {
        when(resultSet.getLong("id")).thenReturn(123L);
        when(resultSet.getLong("workplaceId")).thenReturn(456L);
    }
** Caso do report onde eu não retorno nada dentro do método .query, mas populo map
*** code

    @Override
    public Map<Long, List<String>> findAreasBy(List<Long> locationIds, Integer customerId) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("location_ids", locationIds, Types.INTEGER);
        parameters.addValue("customer_id", customerId, Types.INTEGER);

        final String query = buildFindAreas();

        Map<Long, List<String>> areaByLocationId = new HashMap<>();

        readReplicaNamedParameterJdbcTemplate.query(query, parameters, (rs, row) ->
            areaByLocationId
                    .computeIfAbsent(rs.getLong("location_id"), key -> new ArrayList<>())
                    .add(rs.getString("area_name"))
        );

        return areaByLocationId;
    }

*** test
    @Test
    void deveRetornarMapaComStringDeNomeDeArea() throws SQLException {
        Long locationId = 1234L;
        Integer customerId = 458;
        String areaName = "Area XYZ";
        List<Long> locationIds = Collections.singletonList(locationId);

        ResultSet resultSet = mock(ResultSet.class);
        when(resultSet.getLong("location_id")).thenReturn(locationId);
        when(resultSet.getString("area_name")).thenReturn(areaName);

        ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);

        when(namedParameter.query(anyString(), any(SqlParameterSource.class), rowMapperCaptor.capture()))
                .thenAnswer(invocation -> {
                    RowMapper<?> rowMapper = rowMapperCaptor.getValue();
                    rowMapper.mapRow(resultSet, 1);
                    return null;
                });

        Map<Long, List<String>> actual = nextiControlV2Dao.findAreasBy(locationIds, customerId);

        assertThat(actual.containsKey(locationId)).isTrue();
        assertThat(actual.get(locationId)).containsExactly(areaName);

        verify(namedParameter, times(1)).query(anyString(), any(SqlParameterSource.class), any(RowMapper.class));
    }

** Exemplo de teste onde é salvo um registro no banco e é retornado o id do mesmo (KeyHolder)
*** repository

	public Long saveDataIntoOperationDeskFilter(String name, Long userAccountIdLogged, Long customerId) {

		String query = "INSERT INTO operation_desk_filter(customer_id, name, user_account_id, register_date) " +
				" SELECT :customer_id, :name, :user_account_id, NOW()";

		MapSqlParameterSource parameters = new MapSqlParameterSource();
		parameters.addValue("customer_id", customerId, Types.INTEGER);
		parameters.addValue("name", name, Types.VARCHAR);
		parameters.addValue("user_account_id", userAccountIdLogged, Types.INTEGER);

		KeyHolder keyHolder = new GeneratedKeyHolder();
		namedParameterJdbcTemplate.update(query, parameters, keyHolder, new String[]{"id"});
		return keyHolder.getKey().longValue();
	}
*** teste
    @Test
    void deveSalvarDadosNaTabelaOperationDeskFilterERetornarIdGerado() {
        String name = "Filter Name";
        Long customerId = 1L;
        Long userAccountIdLogged = 123L;
        Long expected = 456L;

        GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
        Map<String, Object> keyMap = new HashMap<>();
        keyMap.put("id", expected);
        keyHolder.getKeyList().add(keyMap);

        doAnswer(invocation -> {
            KeyHolder providedKeyHolder = (KeyHolder) invocation.getArguments()[2];
            providedKeyHolder.getKeyList().add(keyMap);
            return 1;
        }).when(namedParameterJdbcTemplate).update(
                anyString(),
                any(MapSqlParameterSource.class),
                any(KeyHolder.class),
                any(String[].class)
        );

        Long actual = repository.saveDataIntoOperationDeskFilter(name, userAccountIdLogged, customerId);

        assertEquals(expected, actual);
        verify(namedParameterJdbcTemplate).update(
                anyString(),
                any(MapSqlParameterSource.class),
                any(KeyHolder.class),
                any(String[].class)
        );
    }
** Exemplo do report que usa ResultSetExtractor
*** repository

    @Override
    public CustomerDto findLogoAndTimezoneFromCustomer(NextiControlFilterDto filter) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource();
        parameters.addValue("customer_id", filter.getIdsCustomer().get(0), Types.INTEGER);

        final String query = buildLogoAndTimezoneFromCustomerQuery();

        return readReplicaNamedParameterJdbcTemplate.query(query, parameters, rs -> {
                if (rs.next()) {
                    CustomerDto customerDto = new CustomerDto();
                    customerDto.setLogo(rs.getString("logoImagePath"));
                    customerDto.setTimeZone(rs.getString("timezone"));
                    return customerDto;
                } else
                    return null;
            }
        );
    }
*** teste
    @Test
    void deveRetornarDtoComInformacoesDeTimezoneELogoDeCustomer() throws SQLException {
        NextiControlFilterDto filter = getGenericNextiControlFilterDto();
        CustomerDto expected = getCustomerDtoExample();

        doAnswer(invocation -> {
            ResultSet resultSet = mock(ResultSet.class);
            when(resultSet.next()).thenReturn(true);
            when(resultSet.getString("logoImagePath")).thenReturn("https://nexti-files.s3.amazonaws.com/458/Logo/G4S+-++ambriente.png");
            when(resultSet.getString("timezone")).thenReturn("America/Sao_Paulo");

            ResultSetExtractor<ScheduleDto> rse = invocation.getArgumentAt(2, ResultSetExtractor.class);

            return rse.extractData(resultSet);
        }).when(namedParameter)
                .query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));

        CustomerDto actual = nextiControlV2Dao.findLogoAndTimezoneFromCustomer(filter);

        assertEquals(expected, actual);
        verify(namedParameter, times(1)).query(anyString(), any(SqlParameterSource.class), any(ResultSetExtractor.class));
    }

    private CustomerDto getCustomerDtoExample() {
        CustomerDto customerDto = new CustomerDto();
        customerDto.setLogo("https://nexti-files.s3.amazonaws.com/458/Logo/G4S+-++ambriente.png");
        customerDto.setTimeZone("America/Sao_Paulo");
        return customerDto;
    }
** Exemplo do core retornando Optional<String> e usando ResultSetExtractor
	
	@Test
	void deveRetornarOptionalDeTimezoneDoPostoOuDoCustomer() {
		// Given
		String expected = "America/Sao_Paulo";
		OPDQueryParameterDto queryParameterDto = new OPDQueryParameterDto("", new MapSqlParameterSource());

		doAnswer(new Answer<String>() {
			@Override
			public String answer(InvocationOnMock invocation) throws Throwable {
				ResultSet result = mock(ResultSet.class);
				when(result.next()).thenReturn(true);
				when(result.getString("workplaceTimezone")).thenReturn("America/Sao_Paulo");
				ResultSetExtractor<String> rse = invocation.getArgumentAt(2, ResultSetExtractor.class);
				return rse.extractData(result);
			}
		}).when(namedParameter).query(anyString(), any(SqlParameterSource.class), any(ResultSetExtractor.class));

		// When
		Optional<String> actual = repository.findTimezone(queryParameterDto);

		// Then
		assertEquals(expected, actual.get());
		verify(namedParameter, times(1))
				.query(anyString(), any(MapSqlParameterSource.class), any(ResultSetExtractor.class));
	}
** Exemplo de quando usa 
*** repository JdbcTemplate
	private JdbcTemplate readReplicaJdbcTemplate;

    @Override
    public List<PersonDto> findPersonWithClockingButNotAccess(Filter filter) {
		FilterIdsDto filterIdsDto = new FilterIdsDto(filter);

        StringBuilder sql = new StringBuilder();
        sql.append("   select ");
			.....
  


		return readReplicaJdbcTemplate.query(sql.toString(), (rs, rowNum) -> PersonDto.createPersonWithClockingButNotAccess(rs));
    }

*** teste
	@Mock
	private JdbcTemplate readReplicaJdbcTemplate;

	@ParameterizedTest
	@MethodSource("validDataProviderForPersonHasClockingButNotAccessReport")
	void deveRetornarPersonDtoParaGeracaoDeRelatorioDeColaboradoresQuePossuemHorarioNoDiaMasNaoPossuemAcesso(
				String description,	PersonFilterDto filter) throws SQLException {
		PersonDto expected = returnPersonDtoExampleForPersonHasClockingButNotAccessReport();

		ResultSet resultSet = mock(ResultSet.class);
		setPersonDtoWhensForPersonHasClockingButNotAccessReport(resultSet);

		ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);

		when(readReplicaJdbcTemplate.query(anyString(), rowMapperCaptor.capture()))
				.thenAnswer(invocation -> {
					RowMapper<PersonDto> rowMapper = invocation.getArgumentAt(1, RowMapper.class);
					return Arrays.asList(rowMapper.mapRow(resultSet, 1));  //***************************  ", 1"
				});

		List<PersonDto> personDtos = personDao.findPersonWithClockingButNotAccess(filter);
		PersonDto actual = personDtos.get(0);

		assertEquals(expected.toString(), actual.toString());
		verify(readReplicaJdbcTemplate, times(1)).query(anyString(), any(RowMapper.class));
	}



** Exemplo do core
*** test
	@Test
	void deveRetornarColoredShiftIndicatorDtoParaEspecificacaoDoNomeDoHorarioDoDiaRelativoNoCartaoPonto() throws SQLException {
		// Given
		List<ColoredShiftIndicatorDto> expected = returnColoredShiftIndicatorDtoExample();

		ResultSet resultSet = mock(ResultSet.class);
		setColoredShiftIndicatorDtoWhens(resultSet);

		ArgumentCaptor<RowMapper> rowMapperCaptor = ArgumentCaptor.forClass(RowMapper.class);

		when(namedParameter.query(anyString(), any(SqlParameterSource.class), rowMapperCaptor.capture())).thenAnswer(invocation -> {
			RowMapper<ColoredShiftIndicatorDto> rowMapper = invocation.getArgumentAt(2, RowMapper.class);
			return Arrays.asList(rowMapper.mapRow(resultSet, 1));
		});

		List<ColoredShiftIndicatorDto> actual = repo.findSchedulePersonReplacementPeriod(1L, new Date(11111), new Date(22222));

		assertThat(actual).containsExactlyElementsOf(expected);
		verify(namedParameter, times(1)).query(anyString(), any(SqlParameterSource.class), any(RowMapper.class));
	}

* qual a diferença em relação a não passar o eq, mas apenas: verify(redisTemplate, never()).opsForValue(key)?
Na maioria dos casos, especialmente quando lidando com um único argumento, não há diferença prática entre eq(key) e key. Ambos vão verificar se o método foi chamado com um argumento que é igual ao objeto key. A diferença se torna mais significativa quando você está lidando com múltiplos argumentos ou quando você quer usar matchers especiais para realizar verificações mais complexas ou menos estritas.

Se você estiver usando argument matchers como eq, é importante lembrar que você deve usar matchers para todos os argumentos da chamada de método que você está verificando ou simulando. Misturar argumentos diretos e matchers sem seguir essa regra pode levar a um comportamento inesperado ou erros em seus testes.

** posso fazer: verify(redisTemplate, never()).opsForValue(eq(key), any()) ?

Não, você não pode misturar argumentos diretos e matchers do Mockito na mesma chamada de método de verificação. Todos os argumentos devem ser fornecidos por matchers se pelo menos um deles for um matcher. Isso significa que, uma vez que você usa eq(key) ou qualquer outro matcher para um argumento, você deve usar matchers para todos os outros argumentos daquela chamada de método.

** Para corrigir isso, você deve usar matchers para todos os argumentos. Por exemplo:
	verify(redisTemplate, never()).opsForValue(eq(key), any(SecondArgumentType.class));


* caso interessante onde é chamado o setCampo, setando um mock
** Classe de teste
public class ApplicationContextProviderTest  extends TestUnitHelper {
    @InjectMocks
    ApplicationContextProvider service;

    @Test
    public void test_returns_application_context_object() {
        ApplicationContext context = mock(ApplicationContext.class);
        service.setApplicationContext(context);

        ApplicationContext result = service.getApplicationContext();

        assertNotNull(result);
        assertEquals(context, result);
    }
** ApplicationContextProvider.java (classe a ser testada)
@Component
public class ApplicationContextProvider implements ApplicationContextAware {

    private ApplicationContext context;

    public ApplicationContext getApplicationContext() {
        return context;
    }

    @Override
    public void setApplicationContext(ApplicationContext ac) throws BeansException {
        context = ac;
    }
* caso interessante onde é atribuido um valor para ser retornado quando é acessado um método de um campo de valor null
    @Mock
    Authentication authentication;
    @Mock
    SecurityContextHolder securityContextHolder;
    @InjectMocks
    TokenUtil service;

    @Test
    public void test_returns_empty_string_when_authentication_context_has_empty_principal() {
        //Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn("");
        SecurityContextHolder.getContext().setAuthentication(authentication);
* pode até ser que uma classe mockada acessada faça um método static - não está de tudo perdido para determinar o retorno desse método
exemplo: na classe abaixo o método SecurityContextHolder.getContext() é static
dá de atribuir tanto quando SecurityContextHolder está mockado, como quando não está:
    @Test
    public void test_returns_empty_string_when_authentication_context_has_empty_principal() {
        Authentication authentication = mock(Authentication.class);  //*********** Aqui está o ponto importante.... daria pra usar @Mock tb
        SecurityContextHolder.getContext().setAuthentication(authentication); //********* Aqui está o ponto importante: setar um obj mockado
        when(authentication.getPrincipal()).thenReturn("");
        TokenUtil tokenUtil = new TokenUtil();
        String token = tokenUtil.getToken();
        assertEquals("", token);
    }

Sendo que na classe testada está:
    public String getToken() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return (String) authentication.getPrincipal();
    }


* verificar 
** AP: ao que tudo indica o que faz todas as chamadas de métodos externos à outras  classes que não a em teste retornarem null: não é o @Mock dessas outras classes, mas o @InjectMocks
** quando dizemos que um método é static: o que especificamente não conseguimos fazer com ele? Nada? No caso do SecurityContextHolder.getContext() citado num exemplo acima foi possível quando ele estava mockado
