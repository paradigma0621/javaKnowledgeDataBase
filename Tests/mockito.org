* qual a diferença em relação a não passar o eq, mas apenas: verify(redisTemplate, never()).opsForValue(key)?
Na maioria dos casos, especialmente quando lidando com um único argumento, não há diferença prática entre eq(key) e key. Ambos vão verificar se o método foi chamado com um argumento que é igual ao objeto key. A diferença se torna mais significativa quando você está lidando com múltiplos argumentos ou quando você quer usar matchers especiais para realizar verificações mais complexas ou menos estritas.

Se você estiver usando argument matchers como eq, é importante lembrar que você deve usar matchers para todos os argumentos da chamada de método que você está verificando ou simulando. Misturar argumentos diretos e matchers sem seguir essa regra pode levar a um comportamento inesperado ou erros em seus testes.

** posso fazer: verify(redisTemplate, never()).opsForValue(eq(key), any()) ?

Não, você não pode misturar argumentos diretos e matchers do Mockito na mesma chamada de método de verificação. Todos os argumentos devem ser fornecidos por matchers se pelo menos um deles for um matcher. Isso significa que, uma vez que você usa eq(key) ou qualquer outro matcher para um argumento, você deve usar matchers para todos os outros argumentos daquela chamada de método.

** Para corrigir isso, você deve usar matchers para todos os argumentos. Por exemplo:
	verify(redisTemplate, never()).opsForValue(eq(key), any(SecondArgumentType.class));


* caso interessante onde é chamado o setCampo, setando um mock
** Classe de teste
public class ApplicationContextProviderTest  extends TestUnitHelper {
    @InjectMocks
    ApplicationContextProvider service;

    @Test
    public void test_returns_application_context_object() {
        ApplicationContext context = mock(ApplicationContext.class);
        service.setApplicationContext(context);

        ApplicationContext result = service.getApplicationContext();

        assertNotNull(result);
        assertEquals(context, result);
    }
** ApplicationContextProvider.java (classe a ser testada)
@Component
public class ApplicationContextProvider implements ApplicationContextAware {

    private ApplicationContext context;

    public ApplicationContext getApplicationContext() {
        return context;
    }

    @Override
    public void setApplicationContext(ApplicationContext ac) throws BeansException {
        context = ac;
    }
* caso interessante onde é atribuido um valor para ser retornado quando é acessado um método de um campo de valor null
    @Mock
    Authentication authentication;
    @Mock
    SecurityContextHolder securityContextHolder;
    @InjectMocks
    TokenUtil service;

    @Test
    public void test_returns_empty_string_when_authentication_context_has_empty_principal() {
        //Authentication authentication = mock(Authentication.class);
        when(authentication.getPrincipal()).thenReturn("");
        SecurityContextHolder.getContext().setAuthentication(authentication);
* pode até ser que uma classe mockada acessada faça um método static - não está de tudo perdido para determinar o retorno desse método
exemplo: na classe abaixo o método SecurityContextHolder.getContext() é static
dá de atribuir tanto quando SecurityContextHolder está mockado, como quando não está:
    @Test
    public void test_returns_empty_string_when_authentication_context_has_empty_principal() {
        Authentication authentication = mock(Authentication.class);  //*********** Aqui está o ponto importante.... daria pra usar @Mock tb
        SecurityContextHolder.getContext().setAuthentication(authentication); //********* Aqui está o ponto importante: setar um obj mockado
        when(authentication.getPrincipal()).thenReturn("");
        TokenUtil tokenUtil = new TokenUtil();
        String token = tokenUtil.getToken();
        assertEquals("", token);
    }

Sendo que na classe testada está:
    public String getToken() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return (String) authentication.getPrincipal();
    }

* spy
** porque é preciso o uso de spy?
Porque o **spy** (mock parcial) te permite rodar **o método real que você quer testar** (`exportReportToXls`) e, ao mesmo tempo, **neutralizar apenas um pedaço** dele (`addComment(...)`) que:

 não é o foco do teste (o foco é a `IOException` em `response.getOutputStream()`), e
 pode introduzir NPE/efeitos colaterais se o XLSX ou as âncoras/células não estiverem exatamente como o método espera.

Sem spy você teria que:

 montar todo o cenário para o `addComment(...)` (linhas, células, anchors etc.) só para **conseguir** chegar na parte que lança a `IOException`, **ou**
 refatorar o design para injetar um colaborador para comentários.

Em outras palavras, o **spy isola a unidade sob teste**: você executa o fluxo real do export (que é o que quer verificar) e “desliga” o detalhe que não é alvo do teste.

### Quando o spy é a melhor escolha?

 Quando você **não quer** (ou não pode) refatorar agora.
 Quando o método a neutralizar é **não estático** e **público/protected/package-private**.
 Quando precisa **rodar o resto do código “de verdade”**.

> Dica: ao usar spy, prefira `doNothing()/doReturn()` (e não `when(...).then...`) para evitar executar o método real durante o stubbing.

Resumindo: usa-se **spy** para **parcialmente** “mockar” só o que atrapalha, mantendo o restante do fluxo real — e assim o teste foca no que importa (a tradução da `IOException` em `BusinessException`).
** código final do exemplo acima
@Test
void deveLancarBusinessExceptionQuandoIOExceptionNoResponse() throws Exception {
    ExportService service = spy(new ExportService());

    JasperPrint jp = new JasperPrint();
    jp.setPageWidth(595); jp.setPageHeight(842);
    jp.addPage(new JRBasePrintPage());

    doNothing().when(service).addComment(any(), any(), any(), anyInt(), anyInt(), anyString());

    HttpServletResponse response = mock(HttpServletResponse.class);
    when(response.getOutputStream()).thenThrow(new IOException("Erro simulado"));

    BusinessException ex = assertThrows(BusinessException.class,
            () -> service.exportReportToXls(jp, response));
    assertEquals(Translate.use("GENERATE_REPORT_ERROR"), ex.getMessage());
}

* verificar 
** AP: ao que tudo indica o que faz todas as chamadas de métodos externos à outras  classes que não a em teste retornarem null: não é o @Mock dessas outras classes, mas o @InjectMocks
** quando dizemos que um método é static: o que especificamente não conseguimos fazer com ele? Nada? No caso do SecurityContextHolder.getContext() citado num exemplo acima foi possível quando ele estava mockado
