* qual o impacto demonstrado pelo campo "Filtered" no comando  do mysql: explain format=json?
### ğŸ” **O que significa o campo `"filtered"` no `EXPLAIN FORMAT=JSON` do MySQL?**
O campo `"filtered"` no resultado do `EXPLAIN FORMAT=JSON` representa **a porcentagem estimada de linhas que permanecem apÃ³s a aplicaÃ§Ã£o das condiÃ§Ãµes de filtro** (`WHERE`, `ON`, etc.).  
 
Ele indica **quÃ£o seletiva Ã© a condiÃ§Ã£o aplicada** a uma tabela. **Quanto menor o valor de "filtered", maior o nÃºmero de linhas descartadas** pelo MySQL.

---

## **ğŸ“Œ Como interpretar `filtered`?**
O valor `"filtered"` Ã© dado como uma porcentagem **de 0 a 100%**.  

| `"filtered"`    | **InterpretaÃ§Ã£o**                                                              |
|-----------------+--------------------------------------------------------------------------------|
| **100%**        | Todas as linhas da tabela ou Ã­ndice **sÃ£o mantidas** (nenhum filtro aplicado). |
|                 | O MySQL **descarta metade** das linhas depois de aplicar os filtros.           |
| **10%**         | Apenas **10% das linhas** sÃ£o relevantes para a query (muito seletiva).        |
| **1% ou menos** | A tabela tem **muitas linhas descartadas** (possÃ­vel gargalo).                 |

---

## **ğŸ“Œ Exemplo PrÃ¡tico**
Vamos analisar um caso real.

```sql
EXPLAIN FORMAT=JSON 
SELECT * FROM employees 
WHERE department = 'Finance';
```

ğŸ” **Resultado JSON**
```json
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "employees",
      "access_type": "ALL",
      "rows_examined_per_scan": 1000000,
      "rows_produced_per_join": 10000,
      "filtered": "1.00"
    }
  }
}
```

### **ğŸ“Œ Como interpretar?**
- **`rows_examined_per_scan: 1.000.000`** â†’ O MySQL **varreu todas as 1 milhÃ£o de linhas** da tabela.
- **`rows_produced_per_join: 10.000`** â†’ Apenas **10.000 linhas** foram relevantes para o filtro.
- **`filtered: "1.00"`** â†’ O MySQL manteve **apenas 1% das linhas lidas**.

ğŸ“Œ **Problema:**  
ğŸ”´ **A consulta estÃ¡ fazendo FULL TABLE SCAN (`ALL`)!**  
ğŸ”´ **O `"filtered"` estÃ¡ baixo** â†’ Muitas linhas estÃ£o sendo descartadas.  

âœ… **SoluÃ§Ã£o:** Criar um **Ã­ndice no campo `department`** para melhorar a performance:

```sql
CREATE INDEX idx_department ON employees(department);
```

Agora, ao rodar `EXPLAIN FORMAT=JSON` novamente, veremos:

```json
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "employees",
      "access_type": "ref",
      "rows_examined_per_scan": 10000,
      "rows_produced_per_join": 10000,
      "filtered": "100.00"
    }
  }
}
```
ğŸ“Œ **Agora o `"filtered"` estÃ¡ em `100%`!**  
âœ… **O MySQL lÃª apenas as linhas necessÃ¡rias, sem desperdÃ­cio de recursos**.

---

## **ğŸ“Œ Quando `"filtered"` Baixo Indica Problema?**
Se `"filtered"` for muito baixo (1% ou menos), **indica um problema potencial**, como:
- **FULL TABLE SCAN** em tabelas grandes (`ALL` no `access_type`).
- **Falta de Ã­ndices** para as colunas filtradas.
- **Ãndices ineficientes**, que nÃ£o estÃ£o sendo aproveitados pela consulta.
- **Consulta mal escrita** que lÃª mais dados do que precisa.

**Exemplo de problema comum (`filtered` baixo + `ALL`):**
```json
{
  "table_name": "sales",
  "access_type": "ALL",
  "rows_examined_per_scan": 5000000,
  "rows_produced_per_join": 25000,
  "filtered": "0.50"
}
```
ğŸ“Œ **SoluÃ§Ã£o:** Criar Ã­ndices apropriados para reduzir o nÃºmero de linhas examinadas.

---

## **ğŸ“Œ Melhorando Queries com `"filtered"` Baixo**
| ğŸš¨ Problema                                   | âœ… SoluÃ§Ã£o                                                     |
|-----------------------------------------------+----------------------------------------------------------------|
| `"filtered"` baixo (1% ou menos)              | Criar ou melhorar **Ã­ndices** nas colunas do `WHERE`           |
| `"filtered"` alto, mas `ALL` no `access_type` | **Evitar FULL TABLE SCAN**, otimizando `JOINs` e Ã­ndices       |
| `rows_examined_per_scan` muito alto           | **Reduzir leituras desnecessÃ¡rias**, criando Ã­ndices compostos |

---

## **ğŸ¯ ConclusÃ£o**
ğŸ”¹ **O `"filtered"` mostra a eficiÃªncia do filtro** na consulta.  
ğŸ”¹ **Se `"filtered"` estiver baixo, o MySQL estÃ¡ descartando muitas linhas** â†’ **precisa de otimizaÃ§Ã£o**.  
ğŸ”¹ **Usar Ã­ndices corretamente pode aumentar `"filtered"` e reduzir leituras desnecessÃ¡rias**.  

Agora vocÃª pode **identificar gargalos e melhorar a performance** das suas queries com **`EXPLAIN FORMAT=JSON`**! ğŸš€
* qual o papel de um Ã­ndice  numa consulta do mysql?
## ğŸ¯ **O Papel de um Ãndice em uma Consulta do MySQL**
Um **Ã­ndice** no MySQL tem o papel de **acelerar a busca de dados** e **otimizar a performance** das consultas ao reduzir o nÃºmero de leituras necessÃ¡rias para encontrar os registros desejados.

---

## ğŸ”¥ **Como um Ãndice Funciona?**
- Um Ã­ndice funciona **como um Ã­ndice de um livro** ğŸ“–:  
  - **Sem Ã­ndice:** VocÃª precisaria **folhear todas as pÃ¡ginas** para encontrar um capÃ­tulo especÃ­fico (**FULL TABLE SCAN**).  
  - **Com Ã­ndice:** VocÃª **vai direto Ã  pÃ¡gina correta**, reduzindo o tempo de busca.  

ğŸ’¡ **No MySQL, o Ã­ndice permite que a engine do banco de dados encontre os registros de forma muito mais eficiente, evitando a leitura completa da tabela.**

---

## âš¡ **BenefÃ­cios de um Ãndice**
âœ… **Melhora a velocidade das consultas (`SELECT`)**  
âœ… **Evita `FULL TABLE SCAN`, reduzindo I/O**  
âœ… **Otimiza `JOINs` e `ORDER BY`**  
âœ… **Ajuda no `WHERE` e `GROUP BY`**  
âœ… **Melhora `EXPLAIN` e reduz `query_cost`**  

---

## ğŸ” **Tipos de Ãndices no MySQL**
| Tipo de Ãndice     | Uso                                                                 |
|--------------------+---------------------------------------------------------------------|
| **PRIMARY KEY**    | Ãndice Ãºnico para a chave primÃ¡ria.                                 |
| **UNIQUE INDEX**   | Impede valores duplicados.                                          |
| **INDEX (B-TREE)** | Ãndice padrÃ£o para buscas otimizadas.                               |
| **FULLTEXT INDEX** | Ãndice para buscas textuais (`LIKE`, `MATCH` em `VARCHAR`, `TEXT`). |
| **SPATIAL INDEX**  | Ãndice para dados geogrÃ¡ficos (`GEOMETRY`, `POINT`).                |

---

## ğŸš€ **Exemplo PrÃ¡tico**
### **1ï¸âƒ£ Sem Ãndice (FULL TABLE SCAN)**
```sql
EXPLAIN FORMAT=JSON
SELECT * FROM employees WHERE department = 'Finance';
```
ğŸ” **SaÃ­da do EXPLAIN**
```json
{
  "table_name": "employees",
  "access_type": "ALL",
  "rows_examined_per_scan": 1000000
}
```
ğŸ”´ **Problema:** **`access_type: ALL`** â†’ O MySQL estÃ¡ **lendo TODAS as 1 milhÃ£o de linhas**.

---

### **2ï¸âƒ£ Criando um Ãndice**
```sql
CREATE INDEX idx_department ON employees(department);
```
Agora, rodamos a consulta novamente:

```sql
EXPLAIN FORMAT=JSON
SELECT * FROM employees WHERE department = 'Finance';
```
ğŸ” **Nova SaÃ­da**
```json
{
  "table_name": "employees",
  "access_type": "ref",
  "rows_examined_per_scan": 10000
}
```
âœ… **Agora apenas 10.000 linhas foram examinadas, em vez de 1 milhÃ£o**! ğŸš€

---

## âš ï¸ **Quando um Ãndice NÃƒO Ã© Efetivo?**
ğŸ”´ **1. Uso do `LIKE '%valor%'` em Ã­ndices B-TREE**  
```sql
SELECT * FROM customers WHERE name LIKE '%Silva%';
```
ğŸ” **Problema:** O `%` no inÃ­cio impede o uso do Ã­ndice.  
âœ… **SoluÃ§Ã£o:** **Criar um `FULLTEXT INDEX`** para buscas eficientes.  

---

ğŸ”´ **2. Ãndices em Colunas com Poucos Valores Ãšnicos**  
Se vocÃª criar um Ã­ndice em uma coluna com poucos valores distintos (`sexo` = `M` ou `F`), o MySQL **nÃ£o usarÃ¡ o Ã­ndice** porque a filtragem Ã© ineficaz.

```sql
CREATE INDEX idx_sexo ON people(sexo);
```
ğŸ” **Problema:** Como existem poucos valores (`M` e `F`), o MySQL pode achar mais rÃ¡pido **fazer um FULL TABLE SCAN** do que usar o Ã­ndice.

---

ğŸ”´ **3. `ORDER BY` Diferente da OrdenaÃ§Ã£o do Ãndice**  
Se um Ã­ndice for **`(A, B)`**, mas a consulta usar `ORDER BY B`, o Ã­ndice pode ser ignorado.

```sql
CREATE INDEX idx_example ON sales(customer_id, order_date);
```
ğŸš€ **Este Ã­ndice serÃ¡ eficiente para**:
```sql
SELECT * FROM sales WHERE customer_id = 10 ORDER BY order_date;
```
ğŸ”´ **Mas serÃ¡ ineficiente para**:
```sql
SELECT * FROM sales ORDER BY order_date;
```

âœ… **SoluÃ§Ã£o:** Criar um **Ã­ndice separado para `order_date`**.

---

## ğŸ† **ConclusÃ£o**
ğŸ“Œ **Ãndices sÃ£o fundamentais para acelerar consultas e evitar FULL TABLE SCAN.**  
ğŸ“Œ **Use Ã­ndices nas colunas mais filtradas e usadas em `JOINs`, `WHERE`, `ORDER BY`.**  
ğŸ“Œ **Evite Ã­ndices desnecessÃ¡rios para colunas com poucos valores Ãºnicos.**  
ğŸ“Œ **Sempre use `EXPLAIN FORMAT=JSON` para verificar se um Ã­ndice estÃ¡ sendo usado.**  
