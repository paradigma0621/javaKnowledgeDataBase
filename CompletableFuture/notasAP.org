* em rela√ß√£o √† alertar ao rodar .parallelStream()
depende se a collection √© thread safe:
https://stackoverflow.com/questions/60095513/why-is-list-parallelstream-foreach-not-processing-all-the-elements-in-the-li

* Em rela√ß√£o √† c√≥digo que usa @Autowired e @Async
Dependendo n√£o tem como declarar tanto @Autowired como @Async numa mesma classe
** ChatGpt + AP
#+BEGIN_SRC markdown
A anota√ß√£o `@Async` no Spring √© usada para indicar que um m√©todo deve ser executado de forma ass√≠ncrona, ou seja, em um thread separado. Quando usamos a anota√ß√£o `@Async`, o Spring cria um proxy em torno da classe que cont√©m o m√©todo anotado para lidar com a execu√ß√£o ass√≠ncrona.

Quando voc√™ tenta usar `@Autowired` para injetar uma depend√™ncia em um campo de uma classe que tamb√©m cont√©m um m√©todo anotado com `@Async`, pode enfrentar problemas se a inje√ß√£o ocorrer depois da chamada do m√©todo anotado. O que acontece √© que, devido √† cria√ß√£o do proxy, o Spring pode n√£o ter uma refer√™ncia direta ao bean original, e isso pode levar a problemas com a inje√ß√£o de depend√™ncia.

Para resolver esse problema e garantir que as depend√™ncias sejam injetadas corretamente, voc√™ pode seguir uma das seguintes abordagens (AP: As 2 primeiras abordagens n√£o funcionaram)

1. **Inje√ß√£o via construtor** (AP: n√£o funcionou para mim): Ao inv√©s de usar `@Autowired` em campos, use inje√ß√£o via construtor. Isto √©, declare todas as suas depend√™ncias como argumentos no construtor e anote o construtor com `@Autowired`. Isso geralmente √© considerado uma boa pr√°tica porque torna as depend√™ncias mais expl√≠citas e evita problemas relacionados a proxies.

   ```java
   private final SeuServico servico;

   @Autowired
   public SuaClasse(SeuServico servico) {
       this.servico = servico;
   }
   ```

2. **Use `@Lazy` com `@Autowired`**  (AP: n√£o funcionou para mim): Se voc√™ realmente quiser usar a inje√ß√£o de depend√™ncia em campos, pode combinar a anota√ß√£o `@Autowired` com `@Lazy` para garantir que o bean seja injetado quando realmente for acessado:

   ```java
   @Autowired
   @Lazy
   private SeuServico servico;
   ```

3. (AP: Desse modo funcionou!!) **Mova os m√©todos `@Async` para outra classe**: Outra abordagem √© separar os m√©todos que voc√™ deseja executar de forma ass√≠ncrona em uma classe diferente. Desta forma, a classe original n√£o ser√° um proxy e a inje√ß√£o de depend√™ncia funcionar√° como esperado.
AP: O que fiz foi usar o modelo do Core. A classe que tem o @Async √© a mesma que chama por primeiro o campo que vai ser utilizado. Depois deixo a query num m√©todo externo (nessa query que eu precisava rodar: 
    ```
        customerId = customerService.getCurrentCustomerIdWithoutQuery();
    ```
que antes estando na mesma classe `@Autowired CustomerService` e `@Async` n√£o funcionava

#+END_SRC

* JUnit
** Testando o allOf(...).join() da classe CompletableFuture

    @Mock
    private CompletableFuture<Void> ans;

...

            PowerMockito.mockStatic(CompletableFuture.class);
            PowerMockito.when(CompletableFuture.allOf(any(),any())).thenReturn(ans);

        when(ans.join()).thenReturn(null);
* Usando @Async
confirmei que preciso de 
** AsyncConfig.java
@Configuration
@EnableAsync
public class AsyncConfig {
}
** N√£o cheguei a confirmar se esse √© estritamente necess√°rio, mas o ChatGPT diz que sim
deixar o m√©todo que tem o @Async em outra classe que n√£o o seu requisitor
** Usar @Transactional
Pode ser que perca contexto do id do Tenant na  query JPA
nesse caso tem que ressetar o Tenant 
** declarar m√©todos envolvidos como public
n√£o sei se de fato precisa, nem se s√£o todos m√©todos (inclusive os que chamam a @Async)
* Jeito confirmado de fazer processamento paralelo, que n√£o com @Async
** confirmado como efetivo
List<CompletableFuture<JasperPrint>> threads = new ArrayList<>();
			for (int i = 0; i < NUMBER_THREADS; i++) {
				final int index = i;
				JasperReport jasperReport = compileReport(this.getClass().getResourceAsStream(reportFile.getLocation()));
				//TODO Borsatto melhorar nome returnF1 abaixo
				threads.add(CompletableFuture.supplyAsync(() -> returnF1(index, jasperReport, parameters.get(index), listCollectionBean, NUMBER_THREADS)));
			}

			CompletableFuture.allOf(threads.get(0), threads.get(1), threads.get(2), threads.get(3),
									threads.get(4), threads.get(5), threads.get(6), threads.get(7)).join();


	private JasperPrint returnF1(Integer indexThread, JasperReport reportJasper, Map<String, Object> parametros,
								 List<NextiControlDto> listCollectionBean, int NUMBER_THREADS) {
	...
	}
** implementei quando o m√©todo a ser executado √© Void - pelo console confirmei que roda ass√≠ncrono
            CompletableFuture<Void> futureGetBuildAreasNamesCompletableFuture = CompletableFuture.runAsync(() ->
                getBuildAreasNames(listBean, filter)
            );

                CompletableFuture.allOf(taskStageByTaskIdCompletableFuture,
                                        futureGetBuildAreasNamesCompletableFuture,
                                        futureGetBuildChecklistsNamesCompletableFuture).join();

** qual a diferen√ßa entre esses 2 modos de execu√ß√£o? .supplyAsync(()  e   .runAsync(() ?
A diferen√ßa principal entre os dois m√©todos est√° no **retorno do `CompletableFuture`**:

###  **1) `supplyAsync` ‚Äì Retorna um valor**
```java
CompletableFuture<Map<Long, ScheduleAndScheduleTurnNamesDto>> future =
    CompletableFuture.supplyAsync(() -> repo.getScheduleAndScheduleTurn(scheduleIds, customerId));
```
- ‚úÖ **Retorna um `CompletableFuture<Map<Long, ScheduleAndScheduleTurnNamesDto>>`**.
- ‚úÖ A fun√ß√£o passada precisa **retornar um valor**.
- ‚úÖ O valor pode ser obtido depois com `.get()` ou `.join()`.
-  Se ocorrer uma exce√ß√£o, o `CompletableFuture` ser√° completado com erro.

###  **2) `runAsync` ‚Äì Apenas executa uma a√ß√£o, sem retorno**
```java
CompletableFuture<Void> future =
    CompletableFuture.runAsync(() -> repo.getScheduleAndScheduleTurn(scheduleIds, customerId));
```
- ‚úÖ **Retorna um `CompletableFuture<Void>`**.
- ‚úÖ Executa a a√ß√£o, mas **ignora qualquer retorno**.
-  Se `repo.getScheduleAndScheduleTurn(...)` retorna um valor, ele ser√° descartado.
-  N√£o √© poss√≠vel acessar o resultado da execu√ß√£o.

### **Quando usar cada um?**
| M√©todo        | Quando usar?                                                                                                      |
|---------------+-------------------------------------------------------------------------------------------------------------------|
| `supplyAsync` | Quando precisa **recuperar o valor retornado** pela execu√ß√£o ass√≠ncrona.                                          |
| `runAsync`    | Quando s√≥ precisa **executar algo sem se importar com o resultado** (exemplo: log, notifica√ß√£o, envio de e-mail). |

### ‚ö†Ô∏è **No seu caso (`repo.getScheduleAndScheduleTurn(...)` retorna um `Map`), voc√™ deve usar `supplyAsync`**:
```java
CompletableFuture<Map<Long, ScheduleAndScheduleTurnNamesDto>> schedulesAndScheduleTurns =
    CompletableFuture.supplyAsync(() -> repo.getScheduleAndScheduleTurn(scheduleIds, customerId));
```
Caso contr√°rio, o resultado da query ser√° perdido e n√£o poder√° ser utilizado depois.
* c√≥digo de colega a se avaliar
		final CompletableFuture<Void> allOf = CompletableFuture.allOf(futureMapEffectiveDay, futureMapReplacement, clockingFuture);
		allOf.thenRun(() -> listDto.forEach(wor -> wor.getHistoricDates().forEach(historicDates -> {
            processEffectiveDay(filter, wor, historicDates, futureMapEffectiveDay.join());
            processReplacement(wor, historicDates, futureMapReplacement.join());
            processClockingHistoric(wor, historicDates, clockingFuture.join());
        }))).join();

	protected void processClockingHistoric(WorkplaceHistoricDto wor, HistoricDates historicDates, List<ClockingDto> clockingDtoList) {
		if (!NextiUtil.safeNotEmpty(clockingDtoList)) return;
		final List<ClockingDto> filteredAndSortedClocking = clockingDtoList.stream()
                .filter(clockingDto -> historicDates.getReferenceDate().equals(dateFormat.format(clockingDto.getClockingDateTimestamp())) &&
                        clockingDto.getWorkplaceId().equals(wor.getId()))
				.sorted(Comparator.comparing(ClockingDto::getPersonName)
                        .thenComparing(ClockingDto::getClockingDateTimestamp)
                        .thenComparing(ClockingDto::getClockingTypeId)).collect(Collectors.toList());
        historicDates.getClockings().addAll(filteredAndSortedClocking);
	}
* join() vs get()
** pergunta
Dado que foi programado:
        allOf(futureTaskLocationResponseDto,
              futureTaskSupervisorChecklistDtos,
              futureTaskStageLocationResponseDtos,
              futureWorkplaceTaskResponse).join();

Quando eu uso cada uma das op√ß√µes abaixo?

Op√ß√£o 1)
        return new TaskSupervisorDetailedResponseDto(detailedDto,
                                                    futureTaskLocationResponseDto.join(), 
                                                    futureTaskSupervisorChecklistDtos.join(), 
                                                    futureTaskStageLocationResponseDtos.join(), 
                                                    futureWorkplaceTaskResponse.join(), 
                                                    null);
                                                    
Op√ß√£o 2)
        return new TaskSupervisorDetailedResponseDto(detailedDto,
                                                    futureTaskLocationResponseDto.get(), 
                                                    futureTaskSupervisorChecklistDtos.get(), 
                                                    futureTaskStageLocationResponseDtos.get(), 
                                                    futureWorkplaceTaskResponse.get(), 
                                                    null);             

** resposta
A principal diferen√ßa entre as op√ß√µes que utilizam `join()` e `get()` em `CompletableFuture` est√° relacionada ao tratamento de exce√ß√µes e √† maneira como elas bloqueiam a execu√ß√£o.

### Op√ß√£o 1: Usando `join()`
```java
return new TaskSupervisorDetailedResponseDto(detailedDto,
                                             futureTaskLocationResponseDto.join(), 
                                             futureTaskSupervisorChecklistDtos.join(), 
                                             futureTaskStageLocationResponseDtos.join(), 
                                             futureWorkplaceTaskResponse.join(), 
                                             null);
```

- **`join()`** bloqueia a execu√ß√£o atual at√© que o resultado da `CompletableFuture` esteja dispon√≠vel, mas lan√ßa uma exce√ß√£o n√£o verificada (`CompletionException`) se ocorrer um erro durante a execu√ß√£o.
- Como `CompletionException` √© uma exce√ß√£o n√£o verificada, ela n√£o precisa ser explicitamente tratada com um bloco `try-catch` e pode ser propagada automaticamente, sendo mais conveniente para cen√°rios onde voc√™ n√£o quer lidar diretamente com exce√ß√µes verificadas.
- **Uso recomendado**: Se voc√™ n√£o quiser lidar diretamente com exce√ß√µes verificadas, e se estiver confiante de que exce√ß√µes s√£o raras ou j√° foram tratadas em outro lugar.

### Op√ß√£o 2: Usando `get()`
```java
return new TaskSupervisorDetailedResponseDto(detailedDto,
                                             futureTaskLocationResponseDto.get(), 
                                             futureTaskSupervisorChecklistDtos.get(), 
                                             futureTaskStageLocationResponseDtos.get(), 
                                             futureWorkplaceTaskResponse.get(), 
                                             null);
```

- **`get()`** tamb√©m bloqueia a execu√ß√£o at√© que o resultado esteja dispon√≠vel, mas lan√ßa exce√ß√µes verificadas como `InterruptedException` e `ExecutionException`.
- Isso significa que o uso de `get()` exige que voc√™ trate as exce√ß√µes com um bloco `try-catch` ou que declare essas exce√ß√µes na assinatura do m√©todo.
- **Uso recomendado**: Quando voc√™ precisa tratar exce√ß√µes de maneira expl√≠cita ou quer capturar exce√ß√µes verificadas (como quando √© necess√°rio interromper a execu√ß√£o ou tratar a exce√ß√£o gerada pelo `CompletableFuture` de forma mais precisa).

### Resumo
- **Use `join()`** quando n√£o quiser lidar com exce√ß√µes verificadas e preferir a simplicidade de uma exce√ß√£o n√£o verificada que pode ser tratada posteriormente ou propagada.
- **Use `get()`** se voc√™ precisar tratar exce√ß√µes verificadas diretamente ou se o comportamento de lan√ßamento de exce√ß√µes for cr√≠tico para o fluxo de controle do seu programa.

Em ambientes onde voc√™ precisa de maior controle sobre o tratamento de erros, como cen√°rios cr√≠ticos ou de alta confiabilidade, a **op√ß√£o 2** com `get()` pode ser mais apropriada. Para casos onde as exce√ß√µes s√£o raras ou n√£o cr√≠ticas, a **op√ß√£o 1** com `join()` oferece uma sintaxe mais limpa e menos verbosa.


7. Conclusion
In this quick article, we‚Äôve learned that join() and get() are both methods used to retrieve the result of a CompletableFuture, but they handle exceptions differently. The join() method throws unchecked exceptions, making it easier to use when we don‚Äôt want to handle exceptions explicitly. On the other hand, the get() method throws checked exceptions, providing more detailed exception handling and timeout support. Generally, join() should be preferred for new code due to its simplicity, while get() remains available for legacy compatibility.
* exemplo
		List<PersonDto> persons = this.personRepository.findByFilter(filter.getFilterDate(), filter.getWorkplaceIds());
		Map<Long, List<PersonDto>> personMap = persons.stream()
		.collect(Collectors.groupingBy(PersonDto::getWorkplaceId));

return CompletableFuture.allOf(personMap.values().stream()
   .map(this::processPersonsAvatarAsync).toArray(CompletableFuture[]::new))
				.thenApply(v -> persons);

protected CompletableFuture<Void> processPersonsAvatarAsync(List<PersonDto> persons) {
....
	return CompletableFuture.runAsync(() -> persons.forEach(this::processAvatarInPerson));
}

* ao eu chamar 7 vezes um m√©todo ao mesmo tempo:  findValuesUsing(Long customerId, Long workplaceId, Long personId, LocalDate referenceDate) { ... }
√† pertir de 7 m√©todos ass√≠ncronos usando CompletableFutute, sendo que cada um possui valores para os par√¢metros acima diferente entre eles - o java 8 pode se confundir e usar os valores de uma chamada no meio de uma outra?
** resposta
N√£o, o **Java 8 n√£o vai se confundir nem misturar os valores entre chamadas diferentes** de m√©todos, mesmo que eles sejam chamados simultaneamente via `CompletableFuture`. Isso acontece porque:

### ‚úÖ Cada chamada tem sua pr√≥pria pilha de execu√ß√£o

Quando voc√™ faz:

```java
CompletableFuture.supplyAsync(() -> findValuesUsing(...));
```

Cada invoca√ß√£o de `findValuesUsing(...)` √© **independente**, com seus pr√≥prios valores de par√¢metros. O Java aloca uma **pilha de execu√ß√£o separada** para cada chamada, e os argumentos **n√£o s√£o compartilhados** entre elas.

---

### ‚úÖ Par√¢metros s√£o passados por valor (mesmo para objetos)

No Java:

 Para tipos primitivos (`Long`, `int`, etc.), o valor √© copiado.
 Para objetos (`LocalDate`, etc.), √© copiado o **referencial**, mas como voc√™ est√° apenas lendo os valores (n√£o modificando os objetos compartilhados dentro do m√©todo), **n√£o h√° interfer√™ncia**.

---

### üß™ A √∫nica exce√ß√£o seria:

Se voc√™ usasse **vari√°veis compartilhadas mut√°veis** *fora* do m√©todo, como campos est√°ticos ou singletons, **sem sincroniza√ß√£o**. Exemplo ruim:

```java
private static LocalDate referenceDate;

CompletableFuture.runAsync(() -> {
    referenceDate = ...;
    findValuesUsing(...); // usa a vari√°vel est√°tica
});
```

Nesse caso sim, as chamadas poderiam interferir umas nas outras.

---

### ‚úÖ Conclus√£o

Se os par√¢metros s√£o **passados diretamente no m√©todo** e voc√™ **n√£o est√° usando estado global compartilhado**, ent√£o **n√£o h√° qualquer risco de "confus√£o" entre os valores de uma chamada e outra**, mesmo que 7 chamadas ocorram simultaneamente via `CompletableFuture`.

Se quiser posso revisar seu c√≥digo para garantir que ele esteja seguro para execu√ß√£o concorrente.
