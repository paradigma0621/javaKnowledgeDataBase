* Completable Future
** 8. Running Multiple Futures in Parallel 
(fonte: https://www.baeldung.com/java-completablefuture )
When we need to execute multiple Futures in parallel, we usually want to wait for all of them to execute and then process their combined results.

The CompletableFuture.allOf static method allows to wait for completion of all of the Futures provided as a var-arg:

#+BEGIN_SRC java
CompletableFuture<String> future1  
  = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2  
  = CompletableFuture.supplyAsync(() -> "Beautiful");
CompletableFuture<String> future3  
  = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<Void> combinedFuture 
  = CompletableFuture.allOf(future1, future2, future3);

// ...

combinedFuture.get();

assertTrue(future1.isDone());
assertTrue(future2.isDone());
assertTrue(future3.isDone());
#+END_SRC

*** Obs
Notice that the return type of the CompletableFuture.allOf() is a CompletableFuture<Void>. The limitation of this method is that it does not return the combined results of all Futures. Instead, we have to manually get results from Futures. Fortunately, CompletableFuture.join() method and Java 8 Streams API makes it simple:

String combined = Stream.of(future1, future2, future3)
  .map(CompletableFuture::join)
  .collect(Collectors.joining(" "));

assertEquals("Hello Beautiful World", combined);

** exemplo de queries feitas em paralelo (tem que fazer o .get() depois de rodar o CompletableFuture)
CompletableFuture<List<PersonDto>> personsList
					= CompletableFuture.supplyAsync(() -> repo.generateWithBeanPersonsDescendantsFromInput(filter, filter.getReferenceDate()));
CompletableFuture<List<PersonDto>> personsListReplacing
					= CompletableFuture.supplyAsync(() -> repo.generateWithBeanPersonReplacingCandidates(filter, filter.getReferenceDate()));
CompletableFuture.allOf(personsList, personsListReplacing);

//Aqui personsList é do tipo CompletableFuture<List<PersonDto>>

Set<PersonDto> set = new HashSet<PersonDto>();
set.addAll(personsListReplacing.get());
set.addAll(personsList.get());   //personsList.get() é do tipo List<PersonDto>
* Paralell Stream
** exemplo 1
(fonte: https://stackoverflow.com/questions/2016083/what-is-the-easiest-way-to-parallelize-a-task-in-java)
With Java8 and later you can use a parallelStream on the collection to achieve this:

List<T> objects = ...;

List<Result> result = objects.parallelStream().map(object -> {
            return compute(object);
        }).collect(Collectors.toList());
Note: the order of the result list may not match the order in the objects list.

** exemplo 2
(fonte: https://stackoverflow.com/questions/30802463/how-many-threads-are-spawned-in-parallelstream-in-java-8)
list.parallelStream().forEach(/** Do Something */);
* ObjectMapper
** código da main
    public List<PersonDto> convertJsonToMarkingList(String json) {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule()); // Caso estejamos usando algum tipo de data do java 8 (ex: LocalDateTime) pode ser que seja necessário, dependendo das configurações
        try {
            return mapper.readValue(json, new TypeReference<List<PersonDto>>(){});
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
** teste
    @Test
    void deveTetarObjectMapper() {
        LocalDateTime d1 = LocalDateTime.of(2025, 03, 02, 11, 11, 11);
        LocalDateTime d2 = LocalDateTime.of(2029, 03, 04, 1, 2, 3);
        List<PersonDto> expected = List.of(new PersonDto(1L, "João Pedro", d1, "123A", 0L, 11L, false),
                                            new PersonDto(2L, "Paula", d2, "B001", 6L, 5L, true));

        String json  = """
            [{
                "id": 1, 
                "name": "João Pedro",
                "registerDate": "2025-03-02T11:11:11",
                "enrollment": "123A",
                "customerId": 0,
                "profileId": 11,
                "removed": false
            }, 
            {
                "id": 2, 
                "name":  "Paula",
                "registerDate": "2029-03-04T01:02:03",
                "enrollment": "B001",
                "customerId": 6,
                "profileId": 5,
                "removed": true
             }
         ]                
        """;
        PermissionService permissionService = new PermissionService();
        List<PersonDto> actual = permissionService.convertJsonToMarkingList(json);
        assertEquals(expected, actual);
    }
** pom.xml
<dependency>
    <groupId>com.fasterxml.jackson.datatype</groupId>
    <artifactId>jackson-datatype-jsr310</artifactId>
    <version>2.15.0</version> <!-- ou a versão compatível com seu projeto -->
</dependency>


 Dica: Se estiver usando Spring Boot, o registro do JavaTimeModule já é feito automaticamente a partir da versão 2.1+, desde que a dependência jackson-datatype-jsr310 esteja presente no classpath.
