ver também: https://docs.oracle.com/javase/tutorial/information/glossary.html
* conceitos
** Membros da Classe
Atributos (dados) e comportamentos (métodos) de uma classe são chamados de Membros da classe.
** Atributos de uma classe 
-----------
Mesmo que um atributo de uma classe seja definido no final da classe, todos os métodos da classe vão enxergar esse atributo. 
*** Exemplo

 public class Data {
	int dia;
	int mes;
	int ano;

	Data()( {
		dia = 1;
		mes = 1;
		ano = 1970;
	}

	Data(int dia, int mes, int ano) {
		this.dia = dia;
		this.mes = mes;
		this.ano = ano;
	}

	String obterDataFormatada() {
		return String.format(formato, dia, mes, ano); //O método enxerga a String formato definida no fim da classe
	}

	String formato = "%d/%d/%d";
}
-------------------
** Instância
Objeto é sinônimo de instância - posso dizer:
"Eu criei 10 objetos" ou "Eu instânciei 10 objetos".
** Assinatura do Método
int somaValores(int v1, int v2)
Ao que damos o nome de "Identidade do Método" (ou "Assinatura do Método") é a parte:
 somaValores(int v1, int v2)
Não podemos ter 2 métodos com a mesma identidade (mesmo que retornem tipos de dados diferentes).

** Argumentos/declaração de um método
Em geral, um método recebe *argumentos* cujos valores lhe são passados pelo objeto que o chamou, efetua um conjunto de operações e retorna algum resultado. A *declaração* do método especifica o nome do método, o tipo de retorno, o nome e o tipo de cada argumento. Os argumentos são variáveis locais do método em questão. O valor de retorno é devolvido utilizando-se a palavra chave return.

Métodos em Java são análogos a funções e
procedimentos em outras linguagens como VB
e Pascal.
	
** Parâmetro x Argumento
*Parâmetro* é a variável que irá receber um valor em uma função (ou método) enquanto que um *argumento* é o valor (que pode originar de uma variável ou expressão) que você passa para a função (ou método).

Você não passa parâmetros, *você passa argumentos*. Você *recebe argumentos também*, *mas recebe em parâmetros*. Você parametriza sua função com informações que virão posteriormente. Você argumenta com o que deseja executar uma função devidamente parametrizada.

*** exemplo
void Func1(int i, bool flag = true) { //declarou dois parâmetros
    // execução
}

void Func2(params int[] lista) { //declarou um parâmetro
    //execução
}

void Func3(bool x, bool y) {
    int z = 0;
    Func1(1); //chamou com 1 argumento
    Func1(z, x && y); //chamou com dois argumentos vindos de variável e expressão respectivamente
    Func2(1, 2, 3); //chamou com 3 argumentos
    Func1(flag : false, i : 2); //argumentos nomeados
}
** Atribuições: por valor x por referência
*** Atribuição por Valor (quando se trabalha com tipos primitivos):

int a = 2;	//a=2
int b = a;	//b=2

a++;	//a=3;
b--;	//b=1 

*** Atribuição por referência (quando se trabalha com objetos):
Data d1 = new Data();
Data d2 = d1; //d2 aponta para o mesmo endereço de memória que d1 - o que eu fizer a partir de uma variável, a outra também vai enxergar

d2 = new Data(); //d2 vai ganhar um novo endereço de memória e valores de suas variáveis próprios

d1 = d2; //d1 passa a apontar para o endereço de d2, a partir daí o que se mexe com d2 muda d1 e o que mexe com d1 muda d2. 

Data d3 = new Data(); //d3 começa com um novo endereço de memória e valores de suas variáveis próprios
O mesmo acontece quando passamos o d3 por referência para um método:
metodoQueRecebeData(d3);

void metodoQueRecebeData(Data d){
	//o que for mudado aqui muda aqui muda o d3 ali em cima onde foi chamado o método. O mesmo não acontece com a passagem de tipos primitivos, pois destes últimos é feita uma cópia na sua passagem.
	d.dia = 2;
	d.mes = 3;
	d.ano = 2020;
}
** Atributos
*** Variáveis locais
Muitas vezes, variáveis auxiliares são declaradas dentro de um determinado método, ou até dentro de um bloco menor. Tais variáveis são chamadas *locais*. Elas existem somente durante a execução daquele método ou bloco. A parte de código que "enxerga" uma determinada variável é chamada o *escopo* da variável. Assim, o escopo de uma variável global é a classe inteira, e o escopo de uma variável local é o método, ou um bloco contido dentro do método, ao qual ela pertence. 
    
    
• Um método pode ter variáveis locais, que são variáveis declaradas ‘dentro’ do método.
• Variáveis locais podem ser utilizadas apenas dentro do método onde foram declaradas.
• Os parâmetros do método também são locais a ele.
Exemplo:
static float media(float[] v){
	float s = 0;
	for(int i = 0; i < v.length; i++) s += v[i];
	return s/v.length;
}

• Neste exemplo
– v , s e i são variáveis locais ao método media.
– v é parâmetro do método, que é usado como uma variável local.

*** Variável de instância
Uma variável de instância é uma variável cujo valor é específico ao objeto e não à classe. Uma variável de instância em geral possui uma valor diferente em cada objeto membro da classe.
Uma variável é considerada como de instância por "default". 

*** Variável de classe
Uma variável de classe é uma variável cujo valor é comum a todos os objetos membros da classe. Mudar o valor de uma variável de classe em um objeto membro automaticamente muda o valor para todos os objetos membros.
Para declarar uma variável de classe, acrescenta-se a palavra-chave *static*. 

*** Variáveis globais
    Consideremos variáveis declaradas fora de qualquer método (usualmente no cabeçalho da classe). Elas são acessíveis por qualquer método da classe. Tais variáveis são chamadas globais. 

Embora não pareça uma boa ideia, é possível dar a uma variável local um nome que já foi atribuído a uma variável global. Neste caso, a variável local "encobre" a variável global, mas o acesso à variável global é possível usando a palavra-chave this (que fornece uma referência ao próprio objeto) e o operador ponto.

*** Variáveis constantes
    Esta expressão um tanto paradoxal refere-se a variáveis cujo valor não pode mudar durante a execução do programa. Tais variáveis são caracterizadas pela palavra-chave final, e por convenção recebem usualmente nomes escritos inteiramente em maiúsculas.
    Por exemplo, na classe Math do pacote lang, encontramos
       public static final double PI;

    que contem o valor da famosa constante matemática. 
----------------------------------------------
**** Variáveis constantes

    Esta expressão um tanto paradoxal refere-se a variáveis cujo valor não pode mudar durante a execução do programa. Tais variáveis são caracterizadas pela palavra-chave final, e por convenção recebem usualmente nomes escritos inteiramente em maiúsculas.
    Por exemplo, na classe Math do pacote lang, encontramos
       public static final double PI;

    que contem o valor da famosa constante matemática. 
-------------------------------------------------

class Matematica {
	static double Pi=3.14;
}
System.out.println(Matematica.Pi); //Foi possível acessar o valor de Pi sem precisar criar um objeto do tipo Matematica. Isso porque a variável é static. O mesmo vale para métodos static, pois a variável/método é da classe, e não da instância.

Suponhamos que criamos a classe Matematica acima, depois queremos alterar o valor de "Pi" - isso pode ser feito utilizando uma das instâncias da classe Matematica, ou através da classe mesmo:
Ex:

Matematica m1 = new Matematica();
m1.Pi = 3.141;

OU:

Matematica.Pi = 3.1415;

--------------------------------------------------------------------------------------------------------- 
Aida sobre o Pi, caso quiséssemos defini-lo como uma constante, usaríamos:
final static double Pi = 3.1415;
ou
static final double Pi = 3.1415;



---------------------------------------------------------------------------------------------------------
Mesmo que um atributo de uma classe seja definido no final da classe, todos os métodos da classe vão enxergar esse atributo. Ex:
-------------------------------------
 public class Data {
	int dia;
	int mes;
	int ano;

	Data()( {
		dia = 1;
		mes = 1;
		ano = 1970;
	}

	Data(int dia, int mes, int ano) {
		this.dia = dia;
		this.mes = mes;
		this.ano = ano;
	}

	String obterDataFormatada() {
		return String.format(formato, dia, mes, ano); //O método enxerga a String formato definida no fim da classe
	}

	String formato = "%d/%d/%d";
}
-----------------------------------------------

*** Nomeação
Nomes de variáveis devem começar com uma letra, um caráter de sublinhado _ ou um cifrão $. Não podem começar por um número.

** Restrições de acesso
    Algumas palavras-chaves são diponíveis para ampliar ou restringir o acesso a um método. Estas palavras-chaves são acrescentadas à declaração do método.
*** public
    Um método que pode ser acessado por qualquer outra classe é dito público, e é declarado usando-se a palavra-chave public.
*** private
    Um método que pode ser acessado somente por métodos da própria classe é dito privado, e é declarado usando-se a palavra-chave private.
*** protected
    Um método que, além de poder ser acessado por todas as classes do mesmo pacote, também pode ser acessado pelas subclasses da classe na qual ele é declarado, é dito protegido e é declarado usando-se a palavra-chave protected.

*** package
    Um método para o qual não foi especificada nenhuma destas palavras-chaves é dito amigável e pode ser chamado por todas as classes que pertencem ao mesmo pacote. 

*** VER SE ESSE CARA ACRESCENTA ALGO DO QUE FOI DITO ACIMA... SE NÃO: APAGAR ESSE TÓPICO
**** Restrições de acesso

    Algumas palavras-chaves são diponíveis para ampliar ou restringir o acesso a um método. Estas palavras-chaves são acrescentadas à declaração do método.

    Um método que pode ser acessado por qualquer outra classe é dito público, e é declarado usando-se a palavra-chave public.

    Um método que pode ser acessado somente por métodos da própria classe é dito privado, e é declarado usando-se a palavra-chave private.

    Um método que, além de poder ser acessado por todas as classes do mesmo pacote, também pode ser acessado pelas subclasses da classe na qual ele é declarado, é dito protegido e é declarado usando-se a palavra-chave protected.

    Um método para o qual não foi especificada nenhuma destas palavras-chaves é dito amigável e pode ser chamado por todas as classes que pertencem ao mesmo pacote. 




Se você cria um construtor de uma classe como sendo private ninguém consegue fazer instâncias dessa classe. O que seria útil de fazer com ela é usar seus métodos static's.

** Method x Function
*** Question
Can someone provide a simple explanation of methods vs. functions in OOP context?

*** Answer
A method is on an object or is static in class.
A function is independent of any object (and outside of any class).
For Java and C#, there are only methods.

** Argumento x Parâmetro (são duas coisas diferentes)
Primeiro exemplifico, na sequência vem a explanação:

void Func1(int i, bool flag = true) { //declarou dois parâmetros
    // execução
}

void Func2(params int[] lista) { //declarou um parâmetro
    //execução
}

void Func3(bool x, bool y) {
    int z = 0;
    Func1(1); //chamou com 1 argumento
    Func1(z, x && y); //chamou com dois argumentos vindos de variável e expressão respectivamente
    Func2(1, 2, 3); //chamou com 3 argumentos
    Func1(flag : false, i : 2); //argumentos nomeados
}

Parâmetro é a variável que irá receber um valor em uma função (ou método) enquanto que um argumento é o valor (que pode originar de uma variável ou expressão) que você passa para a função (ou método).

Você não passa parâmetros, você passa argumentos. Você recebe argumentos também, mas recebe em parâmetros. Você parametriza sua função com informações que virão posteriormente. Você argumenta com o que deseja executar uma função devidamente parametrizada.

Pode haver menos ou mais argumentos para cada parâmetro já que existem parâmetros que são opcionais e outros que podem ser listas variáveis de dados. Portanto não há uma relação de um para um e a distinção entre eles é importante.

Frequentemente é confundido por todos e eu mesmo admito que intercambio os termos erroneamente, mas para uma boa comunicação é importante todos saberem o correto.

** assinatura de um método
int somaValores(int v1, int v2)
Ao que damos o nome de "Identidade do Método" (ou "Assinatura do Método") é a parte:
 somaValores(int v1, int v2)
Não podemos ter 2 métodos com a mesma identidade (mesmo que retornem tipos de dados diferentes).

** Spring

O Spring é um framework open source para a plataforma Java. Trata-se de um framework não intrusivo, baseado nos padrões de projeto inversão de controle e injeção de dependência.


Spring é um conjunto de projetos que ajudam nós, desenvolvedores, a criar aplicações Java com simplicidade e flexibilidade.

*** Spring versus Java EE

O Spring não chega a ser 100% concorrente do Java EE, até mesmo porque, com Spring, você também usa tecnologias que estão dentro do Java EE.

Mas há quem prefira trabalhar mais com os projetos do Spring (e claro, vai usar Java EE também)...

...e há quem prefira trabalhar apenas com as especificações do Java EE, sem Spring.

Minha sugestão: saia fora dessa guerrinha. Aprenda os dois!

Essa é a postura de um profissional que entende que cada tecnologia tem seus benefícios diferentes.

Como Spring é independente de especificação, a vantagem é que novos projetos são lançados e evoluem muito rápido.

De fato, geralmente o Java EE está atrás do Spring em se tratando de evoluções na plataforma.

Ao mesmo tempo, Java EE tem uma grande especificação por trás, e isso trás uma certa segurança para os desenvolvedores, a custo de uma burocracia e um pouco de demora.

O que eu quero dizer é: você pode até gostar mais de uma plataforma do que da outra, mas é importante conhecer as duas.

*** Spring Boot

O Spring Boot é um framework Java open source que tem como objetivo facilitar esse processo em aplicações Java. Consequentemente, ele traz mais agilidade para o processo de desenvolvimento, uma vez que devs conseguem reduzir o tempo gasto com as configurações iniciais.

--------
Spring Boot is a framework that allows to easily create Spring-powered, production-grade applications and services with the absolute minimum fuss. It takes an opinionated view of the Spring platform designed to work for new and experienced users of Spring.

Spring Boot makes it very easy to create a Spring-powered application with a minimum amount of work. An application created with Spring Boot can be:

    Created without a single line of xml configuration,
    Created without any requirement of an application server because Spring Boot provides an application server (Embed tomcat, jetty or undertow).
    Largely autoconfigured with some sensible defaults and opinionated starter POMs to simplify your maven configuration,
    Provide production-ready features such as metrics, health checks, and externalized configuration.

Spring Boot consists of several (optional) modules

*** Spring MVC

O Spring MVC é um framework que ajuda no desenvolvimento de aplicações web. Com ele nós conseguimos construir aplicações web robustas e flexíveis. 

O Spring MVC é um dos projetos do Spring, que consiste em uma solução action-based para desenvolvimento web usando o padrão MVC.
--------
A framework for building Java web applications based on the Model-View-Controller (MVC) pattern. It promotes flexible and decoupled code from the underlying view technologies.

Spring MVC is an action-based (as opposed to component-based) web framework built on top of the Spring IOC Container. MVC stands for Model View Controller, a long standing design pattern that layers an application separating presentation concerns from business logic see Portland Pattern Repository's MVC Entry

The latest stable version is 5.1.4 and was released in January 2019, and the current docs can be found in the MVC section of the Spring Reference.

Spring Version 5.0 fully supports Java 9 features, this release now requires Java SE 8.
-----------------------------------------

    Spring MVC é uma estrutura MVC completa orientada a HTTP, gerenciada pela Spring Framework e baseada em Servlets. Seria equivalente ao JSF na pilha JavaEE. Os elementos mais populares nele são as classes anotadas @Controller, nas quais você implementa métodos que podem ser acessados ​​usando diferentes solicitações HTTP. Tem um equivalente @RestController para implementar APIs baseadas em REST.

Portanto, o Spring MVC é uma estrutura a ser usada em aplicativos da Web e o Spring Boot é um inicializador de projeto pronto para produção baseado em Spring .

*** Spring Data
Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store.

It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies.

**** Um projeto de exemplo do Spring Data: Spring Data JPA
Ele (o Spring Data JPA) é, na verdade, um projeto dentro de um outro maior que é o Spring Data. O Spring Data tem por objetivo facilitar nosso trabalho com persistência de dados de uma forma geral. E além do Spring Data JPA, ele possui vários outros projetos.

O Spring Data JPA é um framework que nasceu para facilitar a criação dos nossos repositórios.

Ele faz isso nos liberando de ter que implementar as interfaces referentes aos nossos repositórios (ou DAOs), e também já deixando pré-implementado algumas funcionalidades como, por exemplo, de ordenação das consultas e de paginação de registros.

--- (https://blog.algaworks.com/spring-data-jpa/ ):
Gostaria de conhecer um framework que vai mudar (pra melhor) a forma como você implementa a camada de persistência de seus projetos Java?

Não importa se você trabalha com o conceito de DAO ou Repositório, a questão é que você pode ser muito mais produtivo na hora de programar sua camada de persistência se utilizar o Spring Data JPA.

** JPA
Java Persistence API é uma API padrão da linguagem Java que descreve uma interface comum para frameworks de persistência de dados. A JPA define um meio de mapeamento objeto-relacional para objetos Java simples e comuns, denominados beans de entidade.

** boiler plate
Código boilerplate ou boilerplate se refere a seções de código que devem ser incluídas em muitos lugares com pouca ou nenhuma alteração. Ele é muitas vezes usado quando se refere a linguagens que são consideradas detalhadas, onde o programador deve escrever muito código para fazer tarefas mínimas. 

Exemplo de boiler plato: getter and setters de uma classe Dto.
** inversão de controle
Inversão de Controle ou Inversion of Control - conhecido pela Sigla IoC é um Pattern que prega para usarmos o controle das instancias de uma determinada classe ser tratada externamente e não dentro da classe em questão, ou seja, Inverter o controle de uma classe delegando para uma outra classe, interface, componente.

** JSF
O JavaServer Faces (JSF) é um framework de interface de usuário (IU) para aplicações Java Web. Foi projetado para facilitar significativamente a trabalhosa tarefa de escrever e manter os aplicações que são executadas em um servidor de aplicações Java e renderizar as IUs de volta a um cliente de destino.
** JSP
JavaServer Pages (JSP) é uma tecnologia que ajuda os desenvolvedores de software a criarem páginas web geradas dinamicamente baseadas em HTML, XML ou outros tipos de documentos. Lançada em 1999 pela Sun Microsystems, JSP é similar ao PHP, mas usa a linguagem de programação Java.

Para implantar e executar JavaServer Pages, um servidor web compatível com um container servlet, como Apache Tomcat, Jetty ou Glassfish, é requerido.
 
** Servlet
Servlet (servidorzinho em tradução livre) é uma classe Java usada para estender as funcionalidades de um servidor. Apesar dos servlets poderem responder a quaisquer tipos de requisições, eles normalmente são usados para estender as aplicações hospedadas por servidores web, desta forma eles podem ser imaginados como Applets Java que rodam em servidores em vez de rodarem nos navegadores web. Estes tipos de servlets são os equivalentes Java a outras tecnologias de conteúdo Web dinâmico, como PHP e ASP.NET. 
** injeção de dependência é um tipo de inversão de controle
Injeção de dependência não usa a palavra chave "new".

Pode ser feito através da propriedade declarada como @Autowired 
Pode ser feito através do construtor declarado como @Autowired 
Pode ser feito através de um método declarado como @Autowired  (o método padrão é o setter)

** paradigma funcional

*** código em paradigma imperativo (o java começou assim)
public class Imperativo {
    public static void main(String[] args) {
        int valor = 10;
        int resultado = valor * 3;
        System.out.println("O resutado é :: "+resultado);
    }
}

*** código em paradigma funcional (o java suporta hoje)
public class Funcional {
    public static void main(String[] args) {
        UnaryOperator<Integer> calcularValorVezes3 = valor -> valor*3;
        int valor = 10;
        System.out.println("O resutado é :: "+calcularValorVezes3.apply(10));
    }
}
** tipos de variáveis (tipos primitivos e tipos por referência)
	O Java possui dois tipos de dados que são divididos em por valor (tipos primitivos) e por referência (tipos por referência). 
	Os tipos primitivos são boolean, byte, char, short, int, long, float e double. 
	Os tipos por referência, são classes que especificam os tipos de objeto Strings, Arrays Primitivos e Objetos.
	As variáveis de referência são inicializadas com o valor “null” (nulo). 

** variáveis de instância e variáveis de classe
*** Uma *variável de instância* é uma variável cujo valor é específico ao objeto e não à classe. Uma variável de instância em geral possui uma valor diferente em cada objeto membro da classe.
Se vc define a variável no corpo da classe (não de um método) e não utiliza a keyword static, essa variável é de instância. Obs: tipos primitivos também podem ser variáveis de instância.

StackOverflow: variável de instância
	Esta variável pertence ao objeto, concretamente ela só existe quando objeto é criado. Na classe ela serve apenas de planta de como criar o objeto. Em todos os métodos de instância você pode acessá-la porque internamente tem um parâmetro (this) em todos os métodos de instância já que eles recebem o objeto (geralmente por referência) sem você ver.
	Elas só podem ser acessadas através de um objeto. Não pode ser acessada pela classe ou outra forma, tem que dizer de qual objeto você quer a variável.

class Exemplo {
    private int valor;  // Tipo primitivo poder ser variável de instância
    public String nome;
}

*** Uma *variável de classe* é uma variável cujo valor é comum a todos os objetos membros da classe. Mudar o valor de uma variável de classe em um objeto membro automaticamente muda o valor para todos os objetos membros.
Uma variável é considerada como de instância por "default". Para declarar uma variável de classe, acrescenta-se a palavra-chave "static". Exemplos:

static int nuhmeroDeInstahnciasDestaClasse;
static int LEFT = 1;

** variável automática (variável local)
São as variáveis dos métodos, geralmente presentes no stack (pode estar no registrador). Eles tem seu tempo de vida gerenciado automaticamente enquanto o método estiver executando. São chamadas de automáticas por isso.

class Exemplo {
    public static int total;
    private int valor;
    public string nome;
    public string Metodo(int parametro) => (total + valor + parametro).ToString() + nome;
}

Note que parâmetros são variáveis locais, a diferença é só a inicialização que é feita na chamada do método.

** Diferença entre "Atributo" e "Variável de Instância"???

Informalmente os termos são quase intercambiáveis mesmo. Até certo ponto.

O termo atributo é amplamente difundido em linguagens de modelagem como UML. E é comum os programadores Java se referir às variáveis como atributos do objeto, mas formalmente não são. O termo sequer consta da documentação.

Onde está lendo atributo, comece ler campo, porque é isto que está dizendo quando falamos em linguagens de programação. Para as linguagens atributo é outra coisa não relacionada com o que está sendo falado aqui. É a estória da mentira repetida tantas vezes que passou "ser verdade".

Raramente usa-se o termo campo na comunidade Java, mas ele está presente na documentação.

Algumas pessoas preferem o uso de "variáveis de instância" para evitar confusão com outras coisas que podem usar o termo "atributo".

Se são variáveis de instância elas estarão presentes em cada objeto desta classe. Já variáveis de classe são os campos que estão presentes na própria classe e são compartilhados por todos objetos dela.

Estritamente falando, campo é um termo mais geral, assim como "membro" que inclui os campos e métodos da classe.

Um campo pode pertencer à classe ou à instância. Um campo sempre usa uma variável (ou constante) como mecanismo (nunca vi diferente). Então existem variáveis de instância (pertence ao objeto) e variáveis de classe (pertence à classe).



> Como isso influencia durante o processo de programação?

Na programação em si influencia nada, influencia o processo de comunicação. Todos envolvidos precisam entender do que está se falando. Se as pessoas não entendem do que está se falando elas não executarão corretamente, ou o farão por coincidência, por isso eu bato tanto na tecla de usar os termos corretos, isso influencia no resultado final. Alguns acham que é teoria boba, mas afeta a prática sem a pessoa perceber.

Se deseja que crie uma coisa e escreve outra, aí a pessoa que recebeu a informação usa um método que não resolve o problema, a culpa é sua que não usou o termo correto. Se ela criar um campo estático também foi falha de comunicação. Se usar a terminologia corretamente, dentro do contexto, e a pessoa usar errado, a culpa é dela que não sabe o termo correto.

Muitos livros, blogs, e outras fontes usam o termo sem pensar na necessidade da precisão e no contexto que está sendo usado. Em muitos casos, pode não causar confusão, em outros causam mesmo.
** Campo
Campo - Uma parte do objeto que guarda estado dele. Essencialmente é uma variável.

*** exemplo de uso
Class XUZ {
  private List<String> comments; // Dev - Esse campo é usado em algum lugar?
}
** Objetos
    Um objeto é uma instância de uma classe, ou seja uma realização concreta e particular da mesma. Um objeto precisa ser criado. Para que seja possível acessar as variáveis e os métodos de um objeto, é preciso atribuir uma referência ao objeto. O tipo de uma referência, ou seja a classe à qual pertence o objeto ao qual ela vai referir-se, precisa ser declarado.

Declaração: a seguinte instrução declara que a variável nomeDoObjeto refere-se a um objeto instância da classe NomeDaClasse:
  NomeDaClasse nomeDoObjeto;

Criação: a seguinte instrução cria (em memória) um novo objeto instância da classe NomeDaClasse, que será referenciado pela variável nomeDoObjeto previamente declarada:
  nomeDoObjeto = new NomeDaClasse();

As duas instruções acima podem ser combinadas numa só:
  NomeDaClasse nomeDoObjeto = new NomeDaClasse();  
** Objeto x Object
(fonte: StackOverflow)
Tipo primitivo é um objeto?
Cada dado individualizado é um objeto, não importa características específicas, alguns se conformam com Object. Object e objeto são coisas distintas, em níveis diferentes, definem características diferentes, apenas possuem o mesmo nome.
-----------------------------------------------
** Tipo primitivo
boolean var1 = false; //var1 = tipo primitivo
Boolean var2;   ///var2 = objeto


Integer, Boolean, Double,...  = Wrappers
int, double,... = tipos primitivos

** Arquivo Dto (Data Transfer Object)
DTO stands for Data Transfer Object, which is a design pattern. It is one of the EPA patterns which we call when we need to use such objects that encapsulate and aggregate data for transfer. A DTO is similar to a data structure, but like a data structure, it doesn't contain any business logic.
	
** Paradigmas de programação
Paradigma de programação é filosofia máxima de como vamos pensar para construir seu software:
	- Paradigma de Orientação à objetos
	- Paradigma Funcional
	- Paradigma Procedural

Padrão de projeto (eles complementam os paradigmas):
	-exemplo: Observer

** Varargs
//Varargs:

public void comer(Comida... comidas) { //pode-se passar quantos parâmetros quiser
//"comidas" vem como array de "Comida"
	for (Comida c: comidas) {
		this.peso += c.getPeso();
	}
}
** JRE, JDK
Quando alguém quer executar códigos em "Byte Code" (arquivo gerado da compilação: "file.class"), deve instalar em sua máquina o JRE (Java Runtime Enviroment). Obs: dentro do JRE tem a máquina virtual, e a máquina virtual é a base da JRE.

Quando alguém quer uma plataforma para desenvolver em Java, deve instalar o JDK (Java Development Kit).

** pacote
	br.com.cod3r.cm.modelo // onde "cm" = projeto de campo minado, e "modelo" é o nome de um pacote desse projeto
* Básico
** Valores iniciais de variáveis
Variáveis que são inicializadas com valor padrão (zero para variáveis numéricas, false para o boolean) só valem para variáveis de classe ou variáveis de instância. Para variáveis locais obrigatoriamente devemos especificar algum valor.

Quando nós estamos trabalhando com variáveis, as variáveis são:
	- instânciadas com valor padrão quando pertencem à instância, 
		ou são:
	- de classe (nesse último caso temos por exemplo: "static int x;" onde x por padrão começa com valor zero). Já as variáveis locais precisam necessáriamente serem inicializadas de forma explícita.


valores padrões quando se declara uma variável:
byte, short, int, long -> 0
float, double -> 0.0
boolean -> false
char -> '\u0000'

obs: variáveis locais não adquirem valor padrão, apenas as declaradas fora dos métodos (como por exemplo dentro das classes (e fora dos métodos dessa classe)).

obs: objetos de forma geral, quando instanciados, tem valor null. Neles se incluem as variáveis do tipo String... apontam para nenhum local de memória.

-------------------------------

Obs: variáveis final (constantes), quando são de classes, devem receber seu valor na definição do atributo dentro da classe, ou no mais tardar dentro do construtor da classe.
Ou seja:

public class Data {
	final int x; //ou recebe o valor já aqui, ou dentro do construtor

	Data() {
		x=100; //pode receber o valor aqui
	}
}

Outra coisa é que as constantes não são iniciadas com valor padrão, é preciso definir o valor de forma explícita.


* Java 8 - curso da Oracle
https://docs.oracle.com/javase/tutorial/index.html
*** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html
**** Variables
 Do fields have to be initialized when they are declared? Are fields assigned a default value if they are not explicitly initialized? 
 
In the Java programming language, the terms "field" and "variable" are both used; this is a common source of confusion among new developers, since both often seem to refer to the same thing.

The Java programming language defines the following kinds of variables:

***** Instance Variables (Non-Static Fields) 
	Technically speaking, objects store their individual states in "non-static fields", that is, fields declared without the static keyword. Non-static fields are also known as instance variables because their values are unique to each instance of a class (to each object, in other words); the currentSpeed of one bicycle is independent from the currentSpeed of another.

***** Class Variables (Static Fields)
	A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as static since conceptually the same number of gears will apply to all instances. The code static int numGears = 6; would create such a static field. Additionally, the keyword final could be added to indicate that the number of gears will never change.

***** Local Variables
	Similar to how an object stores its state in fields, a method will often store its temporary state in local variables. The syntax for declaring a local variable is similar to declaring a field (for example, int count = 0;). There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared — which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.

***** Parameters 
	You've already seen examples of parameters, both in the Bicycle class and in the main method of the "Hello World!" application. Recall that the signature for the main method is public static void main(String[] args). Here, the args variable is the parameter to this method. The important thing to remember is that parameters are always classified as "variables" not "fields". This applies to other parameter-accepting constructs as well (such as constructors and exception handlers) that you'll learn about later in the tutorial.
***** ...
	Having said that, the remainder of this tutorial uses the following general guidelines when discussing fields and variables. If we are talking about "fields in general" (excluding local variables and parameters), we may simply say "fields". If the discussion applies to "all of the above", we may simply say "variables". If the context calls for a distinction, we will use specific terms (static field, local variables, etc.) as appropriate. You may also occasionally see the term "member" used as well. A type's fields, methods, and nested types are collectively called its members.

***** Naming

	Every programming language has its own set of rules and conventions for the kinds of names that you're allowed to use, and the Java programming language is no different. The rules and conventions for naming your variables can be summarized as follows:

    	Variable names are case-sensitive. A variable's name can be any legal identifier — an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign "$", or the underscore character _ . The convention, however, is to always begin your variable names with a letter, not "$" or "_". Additionally, the dollar sign character, by convention, is never used at all. You may find some situations where auto-generated names will contain the dollar sign, but your variable names should always avoid using it. A similar convention exists for the underscore character; while it's technically legal to begin your variable's name with _, this practice is discouraged. White space is not permitted.

	Subsequent characters may be letters, digits, dollar signs, or underscore characters. Conventions (and common sense) apply to this rule as well. When choosing a name for your variables, use full words instead of cryptic abbreviations. Doing so will make your code easier to read and understand. In many cases it will also make your code self-documenting; fields named cadence, speed, and gear, for example, are much more intuitive than abbreviated versions, such as s, c, and g. Also keep in mind that the name you choose must not be a keyword or reserved word. (AP: ISSO MUDOU NAS OUTRAS VERS DO JAVA?)

	If the name you choose consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, capitalize the first letter of each subsequent word. The names gearRatio and currentGear are prime examples of this convention. If your variable stores a constant value, such as static final int NUM_GEARS = 6, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, the underscore character is never used elsewhere.

*** dúvidas do tópico acima (AP)
Variável local pode ser chamada de campo? Ou o nome correto para elas é apenas variável?

Uma declaração como: 
User operadorDoSistema = new User();
declarada dentro de um método (variável local), pode ser chamada de instância? 	

pode uma instância ser estática?
* O que é uma variável de instância
** perguntando pro Luigi (da empresa)
#+BEGIN_SRC java
class Produto {
    private String nome; //nome é uma variável de instância? R:  Sim
    private String sobrenome = "Silva"; //sobrenome é uma variável de instância?  Sim(Apesar de ter uma valor inicial pode ser modificado em cada instância do objeto, supondo que exista um setter definido)
    private static Double preco; //preco é uma variável de instância?  Não(Como é estático todas as classes compartilham)
    private int x = 1; //x é uma variável de instância?  Sim(Mesmo caso da 2)
	private int m;   //m é uma variável de instância?  Sim

    public void outroMetodo() {
//pessoa, outraPessoa, z, k = Esses eu to na dúvida, porque essas variáveis só existem dentro do método, mas cada instância teria as suas. Segundo ChatGPT não são.... ver tópico "** Código acima, segundo ChatGPT"

        Person pessoa;  //pessoa é uma variável de instância?
        Person outraPessoa = new Person(); //outraPessoa é uma variável de instância?
        int z = 2; //z é uma variável de instância?
        double k; //k é uma variável de instância?
    }
}
#+END_SRC
** Código acima, segundo ChatGPT
#+BEGIN_SRC markdown
Vamos esclarecer:

Variáveis de instância são variáveis que estão no escopo da classe, mas não são estáticas. Elas pertencem a uma instância (objeto) da classe. Portanto, cada vez que um novo objeto é criado, uma nova cópia das variáveis de instância é criada para esse objeto.

Com base na definição acima, no código fornecido, as variáveis de instância são:

1. `nome`
2. `sobrenome`
3. `x`
4. `m`

A variável `preco` não é uma variável de instância, pois é estática. Variáveis estáticas pertencem à classe e não a uma instância específica da classe. Assim, todas as instâncias da classe compartilham a mesma variável estática.

As variáveis `pessoa`, `outraPessoa`, `z` e `k` dentro do método `outroMetodo` são variáveis locais ao método. Elas não são variáveis de instância, pois existem apenas durante a execução do método e não estão no escopo da classe. Cada vez que o método é chamado, essas variáveis são criadas e depois descartadas ao final da execução do método. Mesmo que cada instância possa chamar o método e ter sua "própria" versão das variáveis enquanto o método está sendo executado, isso não as torna variáveis de instância. Variáveis de instância estão no escopo da classe e têm uma duração de vida que é a mesma da instância da classe à qual pertencem.
#+END_SRC
* Dúvidas
** variável x campo
2.1) os nomes "campo" e "variável" são sinônimos no java?
2.2) atributos final são variáveis (pergunto pelo fato de seu valor "não variar")? tipos primitivos são variáveis?
