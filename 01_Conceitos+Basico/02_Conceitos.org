ver tamb√©m: https://docs.oracle.com/javase/tutorial/information/glossary.html
* conceitos
** Membros da Classe
Atributos (dados) e comportamentos (m√©todos) de uma classe s√£o chamados de Membros da classe.
** Atributos de uma classe 
-----------
Mesmo que um atributo de uma classe seja definido no final da classe, todos os m√©todos da classe v√£o enxergar esse atributo. 
*** Exemplo

 public class Data {
	int dia;
	int mes;
	int ano;

	Data()( {
		dia = 1;
		mes = 1;
		ano = 1970;
	}

	Data(int dia, int mes, int ano) {
		this.dia = dia;
		this.mes = mes;
		this.ano = ano;
	}

	String obterDataFormatada() {
		return String.format(formato, dia, mes, ano); //O m√©todo enxerga a String formato definida no fim da classe
	}

	String formato = "%d/%d/%d";
}
-------------------
** Inst√¢ncia
Objeto √© sin√¥nimo de inst√¢ncia - posso dizer:
"Eu criei 10 objetos" ou "Eu inst√¢nciei 10 objetos".
** Assinatura do M√©todo
int somaValores(int v1, int v2)
Ao que damos o nome de "Identidade do M√©todo" (ou "Assinatura do M√©todo") √© a parte:
 somaValores(int v1, int v2)
N√£o podemos ter 2 m√©todos com a mesma identidade (mesmo que retornem tipos de dados diferentes).

** Argumentos/declara√ß√£o de um m√©todo
Em geral, um m√©todo recebe *argumentos* cujos valores lhe s√£o passados pelo objeto que o chamou, efetua um conjunto de opera√ß√µes e retorna algum resultado. A *declara√ß√£o* do m√©todo especifica o nome do m√©todo, o tipo de retorno, o nome e o tipo de cada argumento. Os argumentos s√£o vari√°veis locais do m√©todo em quest√£o. O valor de retorno √© devolvido utilizando-se a palavra chave return.

M√©todos em Java s√£o an√°logos a fun√ß√µes e
procedimentos em outras linguagens como VB
e Pascal.
	
** Par√¢metro x Argumento
*Par√¢metro* √© a vari√°vel que ir√° receber um valor em uma fun√ß√£o (ou m√©todo) enquanto que um *argumento* √© o valor (que pode originar de uma vari√°vel ou express√£o) que voc√™ passa para a fun√ß√£o (ou m√©todo).

Voc√™ n√£o passa par√¢metros, *voc√™ passa argumentos*. Voc√™ *recebe argumentos tamb√©m*, *mas recebe em par√¢metros*. Voc√™ parametriza sua fun√ß√£o com informa√ß√µes que vir√£o posteriormente. Voc√™ argumenta com o que deseja executar uma fun√ß√£o devidamente parametrizada.

*** exemplo
void Func1(int i, bool flag = true) { //declarou dois par√¢metros
    // execu√ß√£o
}

void Func2(params int[] lista) { //declarou um par√¢metro
    //execu√ß√£o
}

void Func3(bool x, bool y) {
    int z = 0;
    Func1(1); //chamou com 1 argumento
    Func1(z, x && y); //chamou com dois argumentos vindos de vari√°vel e express√£o respectivamente
    Func2(1, 2, 3); //chamou com 3 argumentos
    Func1(flag : false, i : 2); //argumentos nomeados
}
** Atribui√ß√µes: por valor x por refer√™ncia
*** Atribui√ß√£o por Valor (quando se trabalha com tipos primitivos):

int a = 2;	//a=2
int b = a;	//b=2

a++;	//a=3;
b--;	//b=1 

*** Atribui√ß√£o por refer√™ncia (quando se trabalha com objetos):
Data d1 = new Data();
Data d2 = d1; //d2 aponta para o mesmo endere√ßo de mem√≥ria que d1 - o que eu fizer a partir de uma vari√°vel, a outra tamb√©m vai enxergar

d2 = new Data(); //d2 vai ganhar um novo endere√ßo de mem√≥ria e valores de suas vari√°veis pr√≥prios

d1 = d2; //d1 passa a apontar para o endere√ßo de d2, a partir da√≠ o que se mexe com d2 muda d1 e o que mexe com d1 muda d2. 

Data d3 = new Data(); //d3 come√ßa com um novo endere√ßo de mem√≥ria e valores de suas vari√°veis pr√≥prios
O mesmo acontece quando passamos o d3 por refer√™ncia para um m√©todo:
metodoQueRecebeData(d3);

void metodoQueRecebeData(Data d){
	//o que for mudado aqui muda aqui muda o d3 ali em cima onde foi chamado o m√©todo. O mesmo n√£o acontece com a passagem de tipos primitivos, pois destes √∫ltimos √© feita uma c√≥pia na sua passagem.
	d.dia = 2;
	d.mes = 3;
	d.ano = 2020;
}
** Atributos
*** Vari√°veis locais
Muitas vezes, vari√°veis auxiliares s√£o declaradas dentro de um determinado m√©todo, ou at√© dentro de um bloco menor. Tais vari√°veis s√£o chamadas *locais*. Elas existem somente durante a execu√ß√£o daquele m√©todo ou bloco. A parte de c√≥digo que "enxerga" uma determinada vari√°vel √© chamada o *escopo* da vari√°vel. Assim, o escopo de uma vari√°vel global √© a classe inteira, e o escopo de uma vari√°vel local √© o m√©todo, ou um bloco contido dentro do m√©todo, ao qual ela pertence. 
    
    
‚Ä¢ Um m√©todo pode ter vari√°veis locais, que s√£o vari√°veis declaradas ‚Äòdentro‚Äô do m√©todo.
‚Ä¢ Vari√°veis locais podem ser utilizadas apenas dentro do m√©todo onde foram declaradas.
‚Ä¢ Os par√¢metros do m√©todo tamb√©m s√£o locais a ele.
Exemplo:
static float media(float[] v){
	float s = 0;
	for(int i = 0; i < v.length; i++) s += v[i];
	return s/v.length;
}

‚Ä¢ Neste exemplo
‚Äì v , s e i s√£o vari√°veis locais ao m√©todo media.
‚Äì v √© par√¢metro do m√©todo, que √© usado como uma vari√°vel local.

*** Vari√°vel de inst√¢ncia
Uma vari√°vel de inst√¢ncia √© uma vari√°vel cujo valor √© espec√≠fico ao objeto e n√£o √† classe. Uma vari√°vel de inst√¢ncia em geral possui uma valor diferente em cada objeto membro da classe.
Uma vari√°vel √© considerada como de inst√¢ncia por "default". 

*** Vari√°vel de classe
Uma vari√°vel de classe √© uma vari√°vel cujo valor √© comum a todos os objetos membros da classe. Mudar o valor de uma vari√°vel de classe em um objeto membro automaticamente muda o valor para todos os objetos membros.
Para declarar uma vari√°vel de classe, acrescenta-se a palavra-chave *static*. 

*** Vari√°veis globais
    Consideremos vari√°veis declaradas fora de qualquer m√©todo (usualmente no cabe√ßalho da classe). Elas s√£o acess√≠veis por qualquer m√©todo da classe. Tais vari√°veis s√£o chamadas globais. 

Embora n√£o pare√ßa uma boa ideia, √© poss√≠vel dar a uma vari√°vel local um nome que j√° foi atribu√≠do a uma vari√°vel global. Neste caso, a vari√°vel local "encobre" a vari√°vel global, mas o acesso √† vari√°vel global √© poss√≠vel usando a palavra-chave this (que fornece uma refer√™ncia ao pr√≥prio objeto) e o operador ponto.

*** Vari√°veis constantes
    Esta express√£o um tanto paradoxal refere-se a vari√°veis cujo valor n√£o pode mudar durante a execu√ß√£o do programa. Tais vari√°veis s√£o caracterizadas pela palavra-chave final, e por conven√ß√£o recebem usualmente nomes escritos inteiramente em mai√∫sculas.
    Por exemplo, na classe Math do pacote lang, encontramos
       public static final double PI;

    que contem o valor da famosa constante matem√°tica. 
----------------------------------------------
**** Vari√°veis constantes

    Esta express√£o um tanto paradoxal refere-se a vari√°veis cujo valor n√£o pode mudar durante a execu√ß√£o do programa. Tais vari√°veis s√£o caracterizadas pela palavra-chave final, e por conven√ß√£o recebem usualmente nomes escritos inteiramente em mai√∫sculas.
    Por exemplo, na classe Math do pacote lang, encontramos
       public static final double PI;

    que contem o valor da famosa constante matem√°tica. 
-------------------------------------------------

class Matematica {
	static double Pi=3.14;
}
System.out.println(Matematica.Pi); //Foi poss√≠vel acessar o valor de Pi sem precisar criar um objeto do tipo Matematica. Isso porque a vari√°vel √© static. O mesmo vale para m√©todos static, pois a vari√°vel/m√©todo √© da classe, e n√£o da inst√¢ncia.

Suponhamos que criamos a classe Matematica acima, depois queremos alterar o valor de "Pi" - isso pode ser feito utilizando uma das inst√¢ncias da classe Matematica, ou atrav√©s da classe mesmo:
Ex:

Matematica m1 = new Matematica();
m1.Pi = 3.141;

OU:

Matematica.Pi = 3.1415;

--------------------------------------------------------------------------------------------------------- 
Aida sobre o Pi, caso quis√©ssemos defini-lo como uma constante, usar√≠amos:
final static double Pi = 3.1415;
ou
static final double Pi = 3.1415;



---------------------------------------------------------------------------------------------------------
Mesmo que um atributo de uma classe seja definido no final da classe, todos os m√©todos da classe v√£o enxergar esse atributo. Ex:
-------------------------------------
 public class Data {
	int dia;
	int mes;
	int ano;

	Data()( {
		dia = 1;
		mes = 1;
		ano = 1970;
	}

	Data(int dia, int mes, int ano) {
		this.dia = dia;
		this.mes = mes;
		this.ano = ano;
	}

	String obterDataFormatada() {
		return String.format(formato, dia, mes, ano); //O m√©todo enxerga a String formato definida no fim da classe
	}

	String formato = "%d/%d/%d";
}
-----------------------------------------------

*** Nomea√ß√£o
Nomes de vari√°veis devem come√ßar com uma letra, um car√°ter de sublinhado _ ou um cifr√£o $. N√£o podem come√ßar por um n√∫mero.

** Restri√ß√µes de acesso
    Algumas palavras-chaves s√£o dipon√≠veis para ampliar ou restringir o acesso a um m√©todo. Estas palavras-chaves s√£o acrescentadas √† declara√ß√£o do m√©todo.
*** public
    Um m√©todo que pode ser acessado por qualquer outra classe √© dito p√∫blico, e √© declarado usando-se a palavra-chave public.
*** private
    Um m√©todo que pode ser acessado somente por m√©todos da pr√≥pria classe √© dito privado, e √© declarado usando-se a palavra-chave private.
*** protected
    Um m√©todo que, al√©m de poder ser acessado por todas as classes do mesmo pacote, tamb√©m pode ser acessado pelas subclasses da classe na qual ele √© declarado, √© dito protegido e √© declarado usando-se a palavra-chave protected.

*** package
    Um m√©todo para o qual n√£o foi especificada nenhuma destas palavras-chaves √© dito amig√°vel e pode ser chamado por todas as classes que pertencem ao mesmo pacote. 

*** VER SE ESSE CARA ACRESCENTA ALGO DO QUE FOI DITO ACIMA... SE N√ÉO: APAGAR ESSE T√ìPICO
**** Restri√ß√µes de acesso

    Algumas palavras-chaves s√£o dipon√≠veis para ampliar ou restringir o acesso a um m√©todo. Estas palavras-chaves s√£o acrescentadas √† declara√ß√£o do m√©todo.

    Um m√©todo que pode ser acessado por qualquer outra classe √© dito p√∫blico, e √© declarado usando-se a palavra-chave public.

    Um m√©todo que pode ser acessado somente por m√©todos da pr√≥pria classe √© dito privado, e √© declarado usando-se a palavra-chave private.

    Um m√©todo que, al√©m de poder ser acessado por todas as classes do mesmo pacote, tamb√©m pode ser acessado pelas subclasses da classe na qual ele √© declarado, √© dito protegido e √© declarado usando-se a palavra-chave protected.

    Um m√©todo para o qual n√£o foi especificada nenhuma destas palavras-chaves √© dito amig√°vel e pode ser chamado por todas as classes que pertencem ao mesmo pacote. 




Se voc√™ cria um construtor de uma classe como sendo private ningu√©m consegue fazer inst√¢ncias dessa classe. O que seria √∫til de fazer com ela √© usar seus m√©todos static's.

** Method x Function
*** Question
Can someone provide a simple explanation of methods vs. functions in OOP context?

*** Answer
A method is on an object or is static in class.
A function is independent of any object (and outside of any class).
For Java and C#, there are only methods.

** Argumento x Par√¢metro (s√£o duas coisas diferentes)
Primeiro exemplifico, na sequ√™ncia vem a explana√ß√£o:

void Func1(int i, bool flag = true) { //declarou dois par√¢metros
    // execu√ß√£o
}

void Func2(params int[] lista) { //declarou um par√¢metro
    //execu√ß√£o
}

void Func3(bool x, bool y) {
    int z = 0;
    Func1(1); //chamou com 1 argumento
    Func1(z, x && y); //chamou com dois argumentos vindos de vari√°vel e express√£o respectivamente
    Func2(1, 2, 3); //chamou com 3 argumentos
    Func1(flag : false, i : 2); //argumentos nomeados
}

Par√¢metro √© a vari√°vel que ir√° receber um valor em uma fun√ß√£o (ou m√©todo) enquanto que um argumento √© o valor (que pode originar de uma vari√°vel ou express√£o) que voc√™ passa para a fun√ß√£o (ou m√©todo).

Voc√™ n√£o passa par√¢metros, voc√™ passa argumentos. Voc√™ recebe argumentos tamb√©m, mas recebe em par√¢metros. Voc√™ parametriza sua fun√ß√£o com informa√ß√µes que vir√£o posteriormente. Voc√™ argumenta com o que deseja executar uma fun√ß√£o devidamente parametrizada.

Pode haver menos ou mais argumentos para cada par√¢metro j√° que existem par√¢metros que s√£o opcionais e outros que podem ser listas vari√°veis de dados. Portanto n√£o h√° uma rela√ß√£o de um para um e a distin√ß√£o entre eles √© importante.

Frequentemente √© confundido por todos e eu mesmo admito que intercambio os termos erroneamente, mas para uma boa comunica√ß√£o √© importante todos saberem o correto.

** assinatura de um m√©todo
int somaValores(int v1, int v2)
Ao que damos o nome de "Identidade do M√©todo" (ou "Assinatura do M√©todo") √© a parte:
 somaValores(int v1, int v2)
N√£o podemos ter 2 m√©todos com a mesma identidade (mesmo que retornem tipos de dados diferentes).

** Spring

O Spring √© um framework open source para a plataforma Java. Trata-se de um framework n√£o intrusivo, baseado nos padr√µes de projeto invers√£o de controle e inje√ß√£o de depend√™ncia.


Spring √© um conjunto de projetos que ajudam n√≥s, desenvolvedores, a criar aplica√ß√µes Java com simplicidade e flexibilidade.

*** Spring versus Java EE

O Spring n√£o chega a ser 100% concorrente do Java EE, at√© mesmo porque, com Spring, voc√™ tamb√©m usa tecnologias que est√£o dentro do Java EE.

Mas h√° quem prefira trabalhar mais com os projetos do Spring (e claro, vai usar Java EE tamb√©m)...

...e h√° quem prefira trabalhar apenas com as especifica√ß√µes do Java EE, sem Spring.

Minha sugest√£o: saia fora dessa guerrinha. Aprenda os dois!

Essa √© a postura de um profissional que entende que cada tecnologia tem seus benef√≠cios diferentes.

Como Spring √© independente de especifica√ß√£o, a vantagem √© que novos projetos s√£o lan√ßados e evoluem muito r√°pido.

De fato, geralmente o Java EE est√° atr√°s do Spring em se tratando de evolu√ß√µes na plataforma.

Ao mesmo tempo, Java EE tem uma grande especifica√ß√£o por tr√°s, e isso tr√°s uma certa seguran√ßa para os desenvolvedores, a custo de uma burocracia e um pouco de demora.

O que eu quero dizer √©: voc√™ pode at√© gostar mais de uma plataforma do que da outra, mas √© importante conhecer as duas.

*** Spring Boot

O Spring Boot √© um framework Java open source que tem como objetivo facilitar esse processo em aplica√ß√µes Java. Consequentemente, ele traz mais agilidade para o processo de desenvolvimento, uma vez que devs conseguem reduzir o tempo gasto com as configura√ß√µes iniciais.

--------
Spring Boot is a framework that allows to easily create Spring-powered, production-grade applications and services with the absolute minimum fuss. It takes an opinionated view of the Spring platform designed to work for new and experienced users of Spring.

Spring Boot makes it very easy to create a Spring-powered application with a minimum amount of work. An application created with Spring Boot can be:

    Created without a single line of xml configuration,
    Created without any requirement of an application server because Spring Boot provides an application server (Embed tomcat, jetty or undertow).
    Largely autoconfigured with some sensible defaults and opinionated starter POMs to simplify your maven configuration,
    Provide production-ready features such as metrics, health checks, and externalized configuration.

Spring Boot consists of several (optional) modules

*** Spring MVC

O Spring MVC √© um framework que ajuda no desenvolvimento de aplica√ß√µes web. Com ele n√≥s conseguimos construir aplica√ß√µes web robustas e flex√≠veis. 

O Spring MVC √© um dos projetos do Spring, que consiste em uma solu√ß√£o action-based para desenvolvimento web usando o padr√£o MVC.
--------
A framework for building Java web applications based on the Model-View-Controller (MVC) pattern. It promotes flexible and decoupled code from the underlying view technologies.

Spring MVC is an action-based (as opposed to component-based) web framework built on top of the Spring IOC Container. MVC stands for Model View Controller, a long standing design pattern that layers an application separating presentation concerns from business logic see Portland Pattern Repository's MVC Entry

The latest stable version is 5.1.4 and was released in January 2019, and the current docs can be found in the MVC section of the Spring Reference.

Spring Version 5.0 fully supports Java 9 features, this release now requires Java SE 8.
-----------------------------------------

    Spring MVC √© uma estrutura MVC completa orientada a HTTP, gerenciada pela Spring Framework e baseada em Servlets. Seria equivalente ao JSF na pilha JavaEE. Os elementos mais populares nele s√£o as classes anotadas @Controller, nas quais voc√™ implementa m√©todos que podem ser acessados ‚Äã‚Äãusando diferentes solicita√ß√µes HTTP. Tem um equivalente @RestController para implementar APIs baseadas em REST.

Portanto, o Spring MVC √© uma estrutura a ser usada em aplicativos da Web e o Spring Boot √© um inicializador de projeto pronto para produ√ß√£o baseado em Spring .

*** Spring Data
Spring Data‚Äôs mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store.

It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies.

**** Um projeto de exemplo do Spring Data: Spring Data JPA
Ele (o Spring Data JPA) √©, na verdade, um projeto dentro de um outro maior que √© o Spring Data. O Spring Data tem por objetivo facilitar nosso trabalho com persist√™ncia de dados de uma forma geral. E al√©m do Spring Data JPA, ele possui v√°rios outros projetos.

O Spring Data JPA √© um framework que nasceu para facilitar a cria√ß√£o dos nossos reposit√≥rios.

Ele faz isso nos liberando de ter que implementar as interfaces referentes aos nossos reposit√≥rios (ou DAOs), e tamb√©m j√° deixando pr√©-implementado algumas funcionalidades como, por exemplo, de ordena√ß√£o das consultas e de pagina√ß√£o de registros.

--- (https://blog.algaworks.com/spring-data-jpa/ ):
Gostaria de conhecer um framework que vai mudar (pra melhor) a forma como voc√™ implementa a camada de persist√™ncia de seus projetos Java?

N√£o importa se voc√™ trabalha com o conceito de DAO ou Reposit√≥rio, a quest√£o √© que voc√™ pode ser muito mais produtivo na hora de programar sua camada de persist√™ncia se utilizar o Spring Data JPA.

** JPA
Java Persistence API √© uma API padr√£o da linguagem Java que descreve uma interface comum para frameworks de persist√™ncia de dados. A JPA define um meio de mapeamento objeto-relacional para objetos Java simples e comuns, denominados beans de entidade.

** boiler plate
C√≥digo boilerplate ou boilerplate se refere a se√ß√µes de c√≥digo que devem ser inclu√≠das em muitos lugares com pouca ou nenhuma altera√ß√£o. Ele √© muitas vezes usado quando se refere a linguagens que s√£o consideradas detalhadas, onde o programador deve escrever muito c√≥digo para fazer tarefas m√≠nimas. 

Exemplo de boiler plato: getter and setters de uma classe Dto.
** invers√£o de controle
Invers√£o de Controle ou Inversion of Control - conhecido pela Sigla IoC √© um Pattern que prega para usarmos o controle das instancias de uma determinada classe ser tratada externamente e n√£o dentro da classe em quest√£o, ou seja, Inverter o controle de uma classe delegando para uma outra classe, interface, componente.

** JSF
O JavaServer Faces (JSF) √© um framework de interface de usu√°rio (IU) para aplica√ß√µes Java Web. Foi projetado para facilitar significativamente a trabalhosa tarefa de escrever e manter os aplica√ß√µes que s√£o executadas em um servidor de aplica√ß√µes Java e renderizar as IUs de volta a um cliente de destino.
** JSP
JavaServer Pages (JSP) √© uma tecnologia que ajuda os desenvolvedores de software a criarem p√°ginas web geradas dinamicamente baseadas em HTML, XML ou outros tipos de documentos. Lan√ßada em 1999 pela Sun Microsystems, JSP √© similar ao PHP, mas usa a linguagem de programa√ß√£o Java.

Para implantar e executar JavaServer Pages, um servidor web compat√≠vel com um container servlet, como Apache Tomcat, Jetty ou Glassfish, √© requerido.
 
** Servlet
Servlet (servidorzinho em tradu√ß√£o livre) √© uma classe Java usada para estender as funcionalidades de um servidor. Apesar dos servlets poderem responder a quaisquer tipos de requisi√ß√µes, eles normalmente s√£o usados para estender as aplica√ß√µes hospedadas por servidores web, desta forma eles podem ser imaginados como Applets Java que rodam em servidores em vez de rodarem nos navegadores web. Estes tipos de servlets s√£o os equivalentes Java a outras tecnologias de conte√∫do Web din√¢mico, como PHP e ASP.NET. 
** inje√ß√£o de depend√™ncia √© um tipo de invers√£o de controle
Inje√ß√£o de depend√™ncia n√£o usa a palavra chave "new".

Pode ser feito atrav√©s da propriedade declarada como @Autowired 
Pode ser feito atrav√©s do construtor declarado como @Autowired 
Pode ser feito atrav√©s de um m√©todo declarado como @Autowired  (o m√©todo padr√£o √© o setter)

** paradigma funcional

*** c√≥digo em paradigma imperativo (o java come√ßou assim)
public class Imperativo {
    public static void main(String[] args) {
        int valor = 10;
        int resultado = valor * 3;
        System.out.println("O resutado √© :: "+resultado);
    }
}

*** c√≥digo em paradigma funcional (o java suporta hoje)
public class Funcional {
    public static void main(String[] args) {
        UnaryOperator<Integer> calcularValorVezes3 = valor -> valor*3;
        int valor = 10;
        System.out.println("O resutado √© :: "+calcularValorVezes3.apply(10));
    }
}
** tipos de vari√°veis (tipos primitivos e tipos por refer√™ncia)
	O Java possui dois tipos de dados que s√£o divididos em por valor (tipos primitivos) e por refer√™ncia (tipos por refer√™ncia). 
	Os tipos primitivos s√£o boolean, byte, char, short, int, long, float e double. 
	Os tipos por refer√™ncia, s√£o classes que especificam os tipos de objeto Strings, Arrays Primitivos e Objetos.
	As vari√°veis de refer√™ncia s√£o inicializadas com o valor ‚Äúnull‚Äù (nulo). 

** vari√°veis de inst√¢ncia e vari√°veis de classe
*** Uma *vari√°vel de inst√¢ncia* √© uma vari√°vel cujo valor √© espec√≠fico ao objeto e n√£o √† classe. Uma vari√°vel de inst√¢ncia em geral possui uma valor diferente em cada objeto membro da classe.
Se vc define a vari√°vel no corpo da classe (n√£o de um m√©todo) e n√£o utiliza a keyword static, essa vari√°vel √© de inst√¢ncia. Obs: tipos primitivos tamb√©m podem ser vari√°veis de inst√¢ncia.

StackOverflow: vari√°vel de inst√¢ncia
	Esta vari√°vel pertence ao objeto, concretamente ela s√≥ existe quando objeto √© criado. Na classe ela serve apenas de planta de como criar o objeto. Em todos os m√©todos de inst√¢ncia voc√™ pode acess√°-la porque internamente tem um par√¢metro (this) em todos os m√©todos de inst√¢ncia j√° que eles recebem o objeto (geralmente por refer√™ncia) sem voc√™ ver.
	Elas s√≥ podem ser acessadas atrav√©s de um objeto. N√£o pode ser acessada pela classe ou outra forma, tem que dizer de qual objeto voc√™ quer a vari√°vel.

class Exemplo {
    private int valor;  // Tipo primitivo poder ser vari√°vel de inst√¢ncia
    public String nome;
}

*** Uma *vari√°vel de classe* √© uma vari√°vel cujo valor √© comum a todos os objetos membros da classe. Mudar o valor de uma vari√°vel de classe em um objeto membro automaticamente muda o valor para todos os objetos membros.
Uma vari√°vel √© considerada como de inst√¢ncia por "default". Para declarar uma vari√°vel de classe, acrescenta-se a palavra-chave "static". Exemplos:

static int nuhmeroDeInstahnciasDestaClasse;
static int LEFT = 1;

** vari√°vel autom√°tica (vari√°vel local)
S√£o as vari√°veis dos m√©todos, geralmente presentes no stack (pode estar no registrador). Eles tem seu tempo de vida gerenciado automaticamente enquanto o m√©todo estiver executando. S√£o chamadas de autom√°ticas por isso.

class Exemplo {
    public static int total;
    private int valor;
    public string nome;
    public string Metodo(int parametro) => (total + valor + parametro).ToString() + nome;
}

Note que par√¢metros s√£o vari√°veis locais, a diferen√ßa √© s√≥ a inicializa√ß√£o que √© feita na chamada do m√©todo.

** Diferen√ßa entre "Atributo" e "Vari√°vel de Inst√¢ncia"???

Informalmente os termos s√£o quase intercambi√°veis mesmo. At√© certo ponto.

O termo atributo √© amplamente difundido em linguagens de modelagem como UML. E √© comum os programadores Java se referir √†s vari√°veis como atributos do objeto, mas formalmente n√£o s√£o. O termo sequer consta da documenta√ß√£o.

Onde est√° lendo atributo, comece ler campo, porque √© isto que est√° dizendo quando falamos em linguagens de programa√ß√£o. Para as linguagens atributo √© outra coisa n√£o relacionada com o que est√° sendo falado aqui. √â a est√≥ria da mentira repetida tantas vezes que passou "ser verdade".

Raramente usa-se o termo campo na comunidade Java, mas ele est√° presente na documenta√ß√£o.

Algumas pessoas preferem o uso de "vari√°veis de inst√¢ncia" para evitar confus√£o com outras coisas que podem usar o termo "atributo".

Se s√£o vari√°veis de inst√¢ncia elas estar√£o presentes em cada objeto desta classe. J√° vari√°veis de classe s√£o os campos que est√£o presentes na pr√≥pria classe e s√£o compartilhados por todos objetos dela.

Estritamente falando, campo √© um termo mais geral, assim como "membro" que inclui os campos e m√©todos da classe.

Um campo pode pertencer √† classe ou √† inst√¢ncia. Um campo sempre usa uma vari√°vel (ou constante) como mecanismo (nunca vi diferente). Ent√£o existem vari√°veis de inst√¢ncia (pertence ao objeto) e vari√°veis de classe (pertence √† classe).



> Como isso influencia durante o processo de programa√ß√£o?

Na programa√ß√£o em si influencia nada, influencia o processo de comunica√ß√£o. Todos envolvidos precisam entender do que est√° se falando. Se as pessoas n√£o entendem do que est√° se falando elas n√£o executar√£o corretamente, ou o far√£o por coincid√™ncia, por isso eu bato tanto na tecla de usar os termos corretos, isso influencia no resultado final. Alguns acham que √© teoria boba, mas afeta a pr√°tica sem a pessoa perceber.

Se deseja que crie uma coisa e escreve outra, a√≠ a pessoa que recebeu a informa√ß√£o usa um m√©todo que n√£o resolve o problema, a culpa √© sua que n√£o usou o termo correto. Se ela criar um campo est√°tico tamb√©m foi falha de comunica√ß√£o. Se usar a terminologia corretamente, dentro do contexto, e a pessoa usar errado, a culpa √© dela que n√£o sabe o termo correto.

Muitos livros, blogs, e outras fontes usam o termo sem pensar na necessidade da precis√£o e no contexto que est√° sendo usado. Em muitos casos, pode n√£o causar confus√£o, em outros causam mesmo.
** Campo
Campo - Uma parte do objeto que guarda estado dele. Essencialmente √© uma vari√°vel.

*** exemplo de uso
Class XUZ {
  private List<String> comments; // Dev - Esse campo √© usado em algum lugar?
}
** Objetos
    Um objeto √© uma inst√¢ncia de uma classe, ou seja uma realiza√ß√£o concreta e particular da mesma. Um objeto precisa ser criado. Para que seja poss√≠vel acessar as vari√°veis e os m√©todos de um objeto, √© preciso atribuir uma refer√™ncia ao objeto. O tipo de uma refer√™ncia, ou seja a classe √† qual pertence o objeto ao qual ela vai referir-se, precisa ser declarado.

Declara√ß√£o: a seguinte instru√ß√£o declara que a vari√°vel nomeDoObjeto refere-se a um objeto inst√¢ncia da classe NomeDaClasse:
  NomeDaClasse nomeDoObjeto;

Cria√ß√£o: a seguinte instru√ß√£o cria (em mem√≥ria) um novo objeto inst√¢ncia da classe NomeDaClasse, que ser√° referenciado pela vari√°vel nomeDoObjeto previamente declarada:
  nomeDoObjeto = new NomeDaClasse();

As duas instru√ß√µes acima podem ser combinadas numa s√≥:
  NomeDaClasse nomeDoObjeto = new NomeDaClasse();  
** Objeto x Object
(fonte: StackOverflow)
Tipo primitivo √© um objeto?
Cada dado individualizado √© um objeto, n√£o importa caracter√≠sticas espec√≠ficas, alguns se conformam com Object. Object e objeto s√£o coisas distintas, em n√≠veis diferentes, definem caracter√≠sticas diferentes, apenas possuem o mesmo nome.
-----------------------------------------------
** Tipo primitivo
boolean var1 = false; //var1 = tipo primitivo
Boolean var2;   ///var2 = objeto


Integer, Boolean, Double,...  = Wrappers
int, double,... = tipos primitivos

** Arquivo Dto (Data Transfer Object)
DTO stands for Data Transfer Object, which is a design pattern. It is one of the EPA patterns which we call when we need to use such objects that encapsulate and aggregate data for transfer. A DTO is similar to a data structure, but like a data structure, it doesn't contain any business logic.
	
** Paradigmas de programa√ß√£o
Paradigma de programa√ß√£o √© filosofia m√°xima de como vamos pensar para construir seu software:
	- Paradigma de Orienta√ß√£o √† objetos
	- Paradigma Funcional
	- Paradigma Procedural

Padr√£o de projeto (eles complementam os paradigmas):
	-exemplo: Observer

** Varargs
//Varargs:

public void comer(Comida... comidas) { //pode-se passar quantos par√¢metros quiser
//"comidas" vem como array de "Comida"
	for (Comida c: comidas) {
		this.peso += c.getPeso();
	}
}
** JRE, JDK
Quando algu√©m quer executar c√≥digos em "Byte Code" (arquivo gerado da compila√ß√£o: "file.class"), deve instalar em sua m√°quina o JRE (Java Runtime Enviroment). Obs: dentro do JRE tem a m√°quina virtual, e a m√°quina virtual √© a base da JRE.

Quando algu√©m quer uma plataforma para desenvolver em Java, deve instalar o JDK (Java Development Kit).

** pacote
	br.com.cod3r.cm.modelo // onde "cm" = projeto de campo minado, e "modelo" √© o nome de um pacote desse projeto
* B√°sico
** Valores iniciais de vari√°veis
Vari√°veis que s√£o inicializadas com valor padr√£o (zero para vari√°veis num√©ricas, false para o boolean) s√≥ valem para vari√°veis de classe ou vari√°veis de inst√¢ncia. Para vari√°veis locais obrigatoriamente devemos especificar algum valor.

Quando n√≥s estamos trabalhando com vari√°veis, as vari√°veis s√£o:
	- inst√¢nciadas com valor padr√£o quando pertencem √† inst√¢ncia, 
		ou s√£o:
	- de classe (nesse √∫ltimo caso temos por exemplo: "static int x;" onde x por padr√£o come√ßa com valor zero). J√° as vari√°veis locais precisam necess√°riamente serem inicializadas de forma expl√≠cita.


valores padr√µes quando se declara uma vari√°vel:
byte, short, int, long -> 0
float, double -> 0.0
boolean -> false
char -> '\u0000'

obs: vari√°veis locais n√£o adquirem valor padr√£o, apenas as declaradas fora dos m√©todos (como por exemplo dentro das classes (e fora dos m√©todos dessa classe)).

obs: objetos de forma geral, quando instanciados, tem valor null. Neles se incluem as vari√°veis do tipo String... apontam para nenhum local de mem√≥ria.

-------------------------------

Obs: vari√°veis final (constantes), quando s√£o de classes, devem receber seu valor na defini√ß√£o do atributo dentro da classe, ou no mais tardar dentro do construtor da classe.
Ou seja:

public class Data {
	final int x; //ou recebe o valor j√° aqui, ou dentro do construtor

	Data() {
		x=100; //pode receber o valor aqui
	}
}

Outra coisa √© que as constantes n√£o s√£o iniciadas com valor padr√£o, √© preciso definir o valor de forma expl√≠cita.

** qual o nome do recurso de validade l√≥gica de:  String quemGanhou = (scorePlayerA > scorePlayerB) ? "Jogador A" : "Jogador B";

O recurso que voc√™ descreveu no c√≥digo Java √© conhecido como operador tern√°rio. O operador tern√°rio √© uma forma curta de expressar uma instru√ß√£o condicional (if-else) em uma √∫nica linha.

A estrutura do operador tern√°rio √© a seguinte:
	condi√ß√£o ? express√£o1 : express√£o2;
* Java 8 - curso da Oracle
https://docs.oracle.com/javase/tutorial/index.html
*** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html
**** Variables
 Do fields have to be initialized when they are declared? Are fields assigned a default value if they are not explicitly initialized? 
 
In the Java programming language, the terms "field" and "variable" are both used; this is a common source of confusion among new developers, since both often seem to refer to the same thing.

The Java programming language defines the following kinds of variables:

***** Instance Variables (Non-Static Fields) 
	Technically speaking, objects store their individual states in "non-static fields", that is, fields declared without the static keyword. Non-static fields are also known as instance variables because their values are unique to each instance of a class (to each object, in other words); the currentSpeed of one bicycle is independent from the currentSpeed of another.

***** Class Variables (Static Fields)
	A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as static since conceptually the same number of gears will apply to all instances. The code static int numGears = 6; would create such a static field. Additionally, the keyword final could be added to indicate that the number of gears will never change.

***** Local Variables
	Similar to how an object stores its state in fields, a method will often store its temporary state in local variables. The syntax for declaring a local variable is similar to declaring a field (for example, int count = 0;). There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared ‚Äî which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.

***** Parameters 
	You've already seen examples of parameters, both in the Bicycle class and in the main method of the "Hello World!" application. Recall that the signature for the main method is public static void main(String[] args). Here, the args variable is the parameter to this method. The important thing to remember is that parameters are always classified as "variables" not "fields". This applies to other parameter-accepting constructs as well (such as constructors and exception handlers) that you'll learn about later in the tutorial.
***** ...
	Having said that, the remainder of this tutorial uses the following general guidelines when discussing fields and variables. If we are talking about "fields in general" (excluding local variables and parameters), we may simply say "fields". If the discussion applies to "all of the above", we may simply say "variables". If the context calls for a distinction, we will use specific terms (static field, local variables, etc.) as appropriate. You may also occasionally see the term "member" used as well. A type's fields, methods, and nested types are collectively called its members.

***** Naming

	Every programming language has its own set of rules and conventions for the kinds of names that you're allowed to use, and the Java programming language is no different. The rules and conventions for naming your variables can be summarized as follows:

    	Variable names are case-sensitive. A variable's name can be any legal identifier ‚Äî an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign "$", or the underscore character _ . The convention, however, is to always begin your variable names with a letter, not "$" or "_". Additionally, the dollar sign character, by convention, is never used at all. You may find some situations where auto-generated names will contain the dollar sign, but your variable names should always avoid using it. A similar convention exists for the underscore character; while it's technically legal to begin your variable's name with _, this practice is discouraged. White space is not permitted.

	Subsequent characters may be letters, digits, dollar signs, or underscore characters. Conventions (and common sense) apply to this rule as well. When choosing a name for your variables, use full words instead of cryptic abbreviations. Doing so will make your code easier to read and understand. In many cases it will also make your code self-documenting; fields named cadence, speed, and gear, for example, are much more intuitive than abbreviated versions, such as s, c, and g. Also keep in mind that the name you choose must not be a keyword or reserved word. (AP: ISSO MUDOU NAS OUTRAS VERS DO JAVA?)

	If the name you choose consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, capitalize the first letter of each subsequent word. The names gearRatio and currentGear are prime examples of this convention. If your variable stores a constant value, such as static final int NUM_GEARS = 6, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, the underscore character is never used elsewhere.

*** d√∫vidas do t√≥pico acima (AP)
Vari√°vel local pode ser chamada de campo? Ou o nome correto para elas √© apenas vari√°vel?

Uma declara√ß√£o como: 
User operadorDoSistema = new User();
declarada dentro de um m√©todo (vari√°vel local), pode ser chamada de inst√¢ncia? 	

pode uma inst√¢ncia ser est√°tica?
* O que √© uma vari√°vel de inst√¢ncia
** perguntando pro Luigi (da empresa)
#+BEGIN_SRC java
class Produto {
    private String nome; //nome √© uma vari√°vel de inst√¢ncia? R:  Sim
    private String sobrenome = "Silva"; //sobrenome √© uma vari√°vel de inst√¢ncia?  Sim(Apesar de ter uma valor inicial pode ser modificado em cada inst√¢ncia do objeto, supondo que exista um setter definido)
    private static Double preco; //preco √© uma vari√°vel de inst√¢ncia?  N√£o(Como √© est√°tico todas as classes compartilham)
    private int x = 1; //x √© uma vari√°vel de inst√¢ncia?  Sim(Mesmo caso da 2)
	private int m;   //m √© uma vari√°vel de inst√¢ncia?  Sim

    public void outroMetodo() {
//pessoa, outraPessoa, z, k = Esses eu to na d√∫vida, porque essas vari√°veis s√≥ existem dentro do m√©todo, mas cada inst√¢ncia teria as suas. Segundo ChatGPT n√£o s√£o.... ver t√≥pico "** C√≥digo acima, segundo ChatGPT"

        Person pessoa;  //pessoa √© uma vari√°vel de inst√¢ncia?
        Person outraPessoa = new Person(); //outraPessoa √© uma vari√°vel de inst√¢ncia?
        int z = 2; //z √© uma vari√°vel de inst√¢ncia?
        double k; //k √© uma vari√°vel de inst√¢ncia?
    }
}
#+END_SRC
** C√≥digo acima, segundo ChatGPT
#+BEGIN_SRC markdown
Vamos esclarecer:

Vari√°veis de inst√¢ncia s√£o vari√°veis que est√£o no escopo da classe, mas n√£o s√£o est√°ticas. Elas pertencem a uma inst√¢ncia (objeto) da classe. Portanto, cada vez que um novo objeto √© criado, uma nova c√≥pia das vari√°veis de inst√¢ncia √© criada para esse objeto.

Com base na defini√ß√£o acima, no c√≥digo fornecido, as vari√°veis de inst√¢ncia s√£o:

1. `nome`
2. `sobrenome`
3. `x`
4. `m`

A vari√°vel `preco` n√£o √© uma vari√°vel de inst√¢ncia, pois √© est√°tica. Vari√°veis est√°ticas pertencem √† classe e n√£o a uma inst√¢ncia espec√≠fica da classe. Assim, todas as inst√¢ncias da classe compartilham a mesma vari√°vel est√°tica.

As vari√°veis `pessoa`, `outraPessoa`, `z` e `k` dentro do m√©todo `outroMetodo` s√£o vari√°veis locais ao m√©todo. Elas n√£o s√£o vari√°veis de inst√¢ncia, pois existem apenas durante a execu√ß√£o do m√©todo e n√£o est√£o no escopo da classe. Cada vez que o m√©todo √© chamado, essas vari√°veis s√£o criadas e depois descartadas ao final da execu√ß√£o do m√©todo. Mesmo que cada inst√¢ncia possa chamar o m√©todo e ter sua "pr√≥pria" vers√£o das vari√°veis enquanto o m√©todo est√° sendo executado, isso n√£o as torna vari√°veis de inst√¢ncia. Vari√°veis de inst√¢ncia est√£o no escopo da classe e t√™m uma dura√ß√£o de vida que √© a mesma da inst√¢ncia da classe √† qual pertencem.
#+END_SRC
* D√∫vidas
** vari√°vel x campo
*** 2.1) os nomes "campo" e "vari√°vel" s√£o sin√¥nimos no java?
N√£o, **"campo" e "vari√°vel" n√£o s√£o sin√¥nimos** em Java. Embora ambos representem **armazenamento de dados**, eles t√™m diferen√ßas importantes no contexto da linguagem.

---
 
### üìå **1. Campo (Field)** (ou Atributo):
Um **campo** √© uma vari√°vel **declarada dentro de uma classe** e que faz parte do estado de um objeto ou da pr√≥pria classe (se for `static`).

üîπ **Exemplo de campos de inst√¢ncia (n√£o est√°ticos):**
```java
public class User {
    private String name;  // Campo de inst√¢ncia
    private int age;      // Campo de inst√¢ncia
}
```
- **Pertence ao objeto** (cada inst√¢ncia tem sua c√≥pia).
- **Pode ter modificadores de acesso** (`private`, `protected`, `public`).
- **Pode ser `final` para garantir imutabilidade**.
- **Mant√©m seu valor durante a vida √∫til do objeto**.

üîπ **Exemplo de campos est√°ticos:**
```java
public class Config {
    public static final String APP_NAME = "MyApp";  // Campo est√°tico (pertence √† classe)
}
```
- **Pertence √† classe e n√£o a uma inst√¢ncia**.
- **√önico valor compartilhado por todas as inst√¢ncias**.
- **Acessado via `Config.APP_NAME` (n√£o precisa de um objeto).**

---

### üìå **2. Vari√°vel**
Uma **vari√°vel** √© um conceito mais amplo. Em Java, o termo "vari√°vel" pode se referir a diferentes tipos de armazenamento tempor√°rio de dados, incluindo **campos**, mas tamb√©m **vari√°veis locais**, **par√¢metros de m√©todo** e **vari√°veis de inst√¢ncia**.

#### üîπ **Tipos de vari√°veis**
| Tipo                    | Onde √© declarada?                         | Tempo de vida                                     |
|-------------------------+-------------------------------------------+---------------------------------------------------|
| **Campo de inst√¢ncia**  | Dentro de uma classe, mas fora de m√©todos | Existe enquanto o objeto existir                  |
| **Campo est√°tico**      | Dentro de uma classe com `static`         | Existe enquanto a classe estiver carregada na JVM |
| **Vari√°vel local**      | Dentro de um m√©todo ou bloco de c√≥digo    | Existe apenas dentro do m√©todo onde foi declarada |
| **Par√¢metro de m√©todo** | Declarada como argumento de um m√©todo     | Existe enquanto o m√©todo estiver em execu√ß√£o      |
|                         |                                           |                                                   |

üîπ **Exemplo de vari√°veis locais e par√¢metros:**
```java
public void process(String input) {  // "input" √© um par√¢metro de m√©todo
    int count = 10;  // "count" √© uma vari√°vel local
    System.out.println(input + " - " + count);
}
```
- **Vari√°veis locais vivem apenas dentro do m√©todo** e n√£o podem ter modificadores de acesso (`public`, `private`, etc.).
- **Par√¢metros s√£o vari√°veis que recebem valores passados para o m√©todo.**

---

### üìå **Resumo**
| Termo             | Defini√ß√£o                                                                  | Exemplos                                                |
|-------------------+----------------------------------------------------------------------------+---------------------------------------------------------|
| **Campo (Field)** | Vari√°vel declarada em uma classe, pode ser de inst√¢ncia ou est√°tica        | `private String name;` ou `static final int MAX = 100;` |
| **Vari√°vel**      | Qualquer valor armazenado, incluindo campos, vari√°veis locais e par√¢metros | `int number = 5;` dentro de um m√©todo                   |

üí° **Conclus√£o:**  
Todos os **campos s√£o vari√°veis**, mas **nem todas as vari√°veis s√£o campos**. Vari√°veis podem existir apenas dentro de m√©todos, enquanto campos pertencem a objetos ou classes.
*** 2.2) atributos final s√£o vari√°veis (pergunto pelo fato de seu valor "n√£o variar")? tipos primitivos s√£o vari√°veis?
