pegar conteudo daqui:
https://www.digitalocean.com/community/tutorials/java-string


	
* Strings
** MÃºltiplas criaÃ§Ãµes
Cada subconcatenaÃ§Ã£o de strings gera uma string no Pool de Strings. Ex:
"a" + "b" + "c"
gera no Pool de Strings:
"a", "b", "c", "ab", "abc"

ou seja: quando for fazer vÃ¡rias concatenaÃ§Ãµes (em laÃ§os "for", por exemplo) considerar usar stringbuilder.

** equalsIgnoreCase
String valor = "abc";
while(!"sair".equalsIgnoreCase(valor)) { ... }
* DÃºvidas
** CriaÃ§Ã£o de String
Na aula 477 o Leoardo falou que nÃ£o se faz a atribuiÃ§Ã£o do valor da String dentro da chamada new - por exemplo:
String nome = new String("JoÃ£o"); //assim nÃ£o se faz

--
Qual o melhor modo entÃ£o? Assim: (??)
String nome = new String();
nome="Pedro";
(??)


* myStr.codePoints()
No **Java 8**, o mÃ©todo **`s.codePoints()`** retorna um **`IntStream`** dos **cÃ³digos Unicode** (code points) da `String s`.

---

## **O que Ã© um code point?**
Em Unicode, um **code point** Ã© um nÃºmero inteiro que representa um caractere. Ele pode ser de **16 bits** (para caracteres comuns) ou **32 bits** (para caracteres especiais, como emojis e sÃ­mbolos raros).

- O Java **representa Strings internamente como UTF-16**, onde cada **char** pode ocupar **1 ou 2 unidades de 16 bits**.
- O mÃ©todo **`s.codePoints()`** retorna um fluxo (`IntStream`) de inteiros correspondentes a cada **code point**, garantindo que caracteres acima de `0xFFFF` sejam corretamente interpretados.

---

## **Exemplo Simples**
```java
public class CodePointsExample {
    public static void main(String[] args) {
        String s = "AğˆB"; // O caractere ğˆ Ã© um code point acima de U+FFFF

        s.codePoints().forEach(cp -> System.out.println("Code point: " + cp));
    }
}
```

**SaÃ­da:**
```
Code point: 65   // 'A' â†’ U+0041
Code point: 66312 // 'ğˆ' â†’ U+10348 (representado por dois `char`)
Code point: 66   // 'B' â†’ U+0042
```

---

## **DiferenÃ§a entre `codePoints()` e `chars()`**
- **`s.chars()`** retorna um **`IntStream` de `char`**, onde cada elemento tem **16 bits** (`char`).
- **`s.codePoints()`** retorna um **`IntStream` de cÃ³digo Unicode completo**, considerando caracteres que precisam de **dois `char`**.

**Exemplo comparativo:**
```java
String s = "ğˆA"; // ContÃ©m um caractere que ocupa 2 `char`

System.out.println("chars():");
s.chars().forEach(c -> System.out.println(c));

System.out.println("\ncodePoints():");
s.codePoints().forEach(cp -> System.out.println(cp));
```

**SaÃ­da (`chars()`)**:
```
chars():
55304  // Primeiro `char` de 'ğˆ'
56392  // Segundo `char` de 'ğˆ'
65     // 'A'
```
Aqui, `chars()` nÃ£o trata `ğˆ` corretamente e divide em duas unidades UTF-16.

**SaÃ­da (`codePoints()`)**:
```
codePoints():
66312  // 'ğˆ'
65     // 'A'
```
Aqui, `codePoints()` trata `ğˆ` corretamente como um Ãºnico nÃºmero.

---

## **Usos Comuns**
âœ… **Converter String em lista de caracteres Unicode**
```java
List<Integer> codePointList = s.codePoints().boxed().collect(Collectors.toList());
System.out.println(codePointList);
```

âœ… **Remover caracteres nÃ£o-ASCII**
```java
String filtered = s.codePoints()
                   .filter(cp -> cp <= 127)  // MantÃ©m apenas ASCII
                   .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
                   .toString();
```

âœ… **Contar caracteres Unicode corretamente**
```java
long count = s.codePoints().count();
```
Isso evita contar caracteres **duas vezes** quando sÃ£o representados por dois `char`.

---

### **ConclusÃ£o**
- **`s.codePoints()`** retorna um **`IntStream`** de **code points Unicode**.
- **Garante que caracteres acima de `0xFFFF` sejam tratados corretamente**.
- **Diferente de `chars()`, que retorna unidades UTF-16 individuais**.
