* Modificaor do tipo 'final'
** pergunta
Com que frequência se deve dar o uso de atribuição tipo "final" para campos no java? O maior número de vezes possível?
A dúvida é maior no que se refere à campos do tipo não primitivos, pois para esses pode ser atribuido a classificação de final, e serem realizadas operações de atribuições para os mesmos (ex: um objeto de lista de Long, onde atribuímos:
final List<Long> numbers = new ArrayList<>();
numbers.add(1L);
numbers.add(2L);
System.out.println(numbers);
numbers.set(0, 99L);
System.out.println(numbers);
ou seja: apesar de a List ser final, foi reatribuir um valor para a mesma no seu objeto de índice 0. Ela deveria ter sido classificada como do tipo final?

Idem para o código abaixo:
final RectangleDto rectangleDto = new RectangleDto(30L, 40L);
rectangleDto.setWidth(50L);
System.out.println(rectangleDto.toString());

class RectangleDto {
Long width;
Long height;

```
 public RectangleDto(Long width, Long height) {
     this.width = width;
     this.height = height;
 }

 public Long getWidth() {
     return width;
 }

 public void setWidth(Long width) {
     this.width = width;
 }

 public Long getHeight() {
     return height;
 }

 public void setHeight(Long height) {
     this.height = height;
 }

 @Override
 public String toString() {
     return "RectangleDto{" +
             "width=" + width +
             ", height=" + height +
             '}';
 }
```

}

Deveríamos atribuir a classificação de tipo final ao RectangleDto?
Pois nós e fizemos e posteriormente modificamos o atributo width.

--------------------------------------------------
** resposta
*** síntese final de todos os sub-tópicos abaixo
O modificador `final` em Java impede que uma variável seja **reatribuída** após inicializada, mas **não torna o objeto referenciado imutável**. Ou seja, em `final List<Long> lista = new ArrayList<>();` a referência `lista` não pode apontar para outro objeto, mas ainda é possível modificar o conteúdo da lista (por exemplo, `lista.add(10L)`). Do mesmo modo, em `final RectangleDto rect = new RectangleDto();`, não se pode fazer `rect = new RectangleDto(...)` (erro de compilação), mas ainda se pode alterar o estado de `rect` chamando, por exemplo, `rect.setWidth(10)`. Assim, **final garante apenas a imutabilidade da referência**, não do objeto interno.

## 8. Conclusão das diretrizes

Em síntese, as recomendações atuais sobre o uso de `final` em Java são:

-* **Campos de classe:** marcar como `final` sempre que não precisar mudar a referência depois da construção do objeto. Isso promove imutabilidade segura e padrões de design sólidos.
-* **Variáveis locais:** usar `final` conforme convenha à clareza do método. Em métodos complexos, pode ajudar a documentar fluxo e evitar erros. Porém, não é obrigatório em todo lugar – avalie caso a caso.
-* **Parâmetros de método:** tipicamente **não usar** `final` em parâmetros. Eles devem ser tratados como valores de entrada imutáveis por definição, e adicionar `final` costuma apenas poluir visualmente a assinatura.
-* **Tipos mutáveis (listas, DTOs etc.):** lembre-se de que `final` não torna o objeto imutável. Use-o apenas para fixar a referência. Para imutabilidade real, use coleções ou objetos imutáveis explicitamente.
-* **Produção vs Testes:** aplique a mesma convenção de `final` nos testes que no código de produção, seguindo as normas do time. Não há regra distinta de mercado para isso.
-* **IDE e manutenção:** IDEs modernas sinalizam variáveis que “podem ser final” (ex.: IntelliJ ). Isso pode orientar a consistência. No entanto, respeito pela legibilidade do código deve guiar a escolha – não acrescente `final` só por usar.

Em linhas gerais, recomenda-se **marcar como final os campos e variáveis que naturalmente atuam como constantes de instância**, preservando referências fixas, enquanto se evita uso indiscriminado nos demais casos. Essa abordagem moderna equilibra segurança e clareza, facilitando a manutenção e a compreensão do código Java.

**Fontes:** Documentação oficial Java e guias de estilo (Google Java Style Guide), *Effective Java* (Joshua Bloch), artigos técnicos de especialistas e discussões da comunidade (StackOverflow, blogs especializados) fornecem as bases para as recomendações acima.


*** # Uso do modificador `final` em Java: boas práticas modernas

O modificador `final` em Java impede que uma variável seja **reatribuída** após inicializada, mas **não torna o objeto referenciado imutável**. Ou seja, em `final List<Long> lista = new ArrayList<>();` a referência `lista` não pode apontar para outro objeto, mas ainda é possível modificar o conteúdo da lista (por exemplo, `lista.add(10L)`). Do mesmo modo, em `final RectangleDto rect = new RectangleDto();`, não se pode fazer `rect = new RectangleDto(...)` (erro de compilação), mas ainda se pode alterar o estado de `rect` chamando, por exemplo, `rect.setWidth(10)`. Assim, **final garante apenas a imutabilidade da referência**, não do objeto interno.

*** ## 1. Final x mutabilidade e legibilidade

Marcar uma variável como `final` transmite a intenção de que ela não será reatribuída. Isso pode ajudar na leitura do código, pois o leitor sabe que aquele identificador não muda de valor após a inicialização. De fato, desenvolvedores experientes observam que “é mais fácil raciocinar sobre os possíveis estados do programa quando se sabe que variáveis são atribuídas **uma única vez**”. Em métodos longos ou complexos, `final` pode servir como documentação implícita de que certas variáveis agem como constantes locais após definidas.

Por outro lado, o uso excessivo de `final` (por exemplo, em **todos** os parâmetros e variáveis locais) pode “poluir” o código com palavras-chave adicionais, tornando a leitura mais cansativa e as linhas mais longas. Vários guias e especialistas apontam que declarar **tudo** como `final` acaba escondendo o propósito real, sem ganhos relevantes de correção, e vai contra recomendações de *código limpo* que prezam pela simplicidade. De fato, o **Google Java Style Guide** não se pronuncia especificamente sobre marcar parâmetros/locais como `final`, refletindo a falta de consenso na comunidade sobre seu uso generalizado.

> **Resumo:** `final` melhora a legibilidade ao fixar referências (facilitando o raciocínio), mas seu uso indiscriminado pode gerar código verboso sem ganho claro. Deve-se equilibrar clareza e concisão.

*** ## 2. `final` em campos de classe

Em **campos de classe** (atributos de instância ou estáticos), a prática recomendada é marcá-los como `final` sempre que possível. Isso garante que o campo seja inicializado uma única vez (normalmente no construtor ou na declaração) e não possa ser reatribuído depois, o que leva a designs mais seguros e fáceis de entender. Como observado por Rotteveel (Java Champion), “se o campo é `final`, ele sempre aponta para o mesmo objeto, mas esse objeto em si pode ser mutável”. Em outras palavras, `final` em campos impede troca de referência, mas **não impede** que esse objeto interno mude de estado.

Princípios consagrados afirmam que, exceto quando realmente necessário, devemos “tornar todos os campos *final*”. Joshua Bloch (em *Effective Java*) e Brian Goetz (em *Java Concurrency in Practice*) reforçam que campos imutáveis (todos `final` e de objetos imutáveis) são mais seguros para publicação em múltiplas threads. Em código moderno orientado a objetos, muitas classes mantêm apenas referências imutáveis ou constantes nas instâncias, de modo que os campos tendem a ser marcados como `final` por padrão.

Por exemplo:

```java
public class Order {
    private final Long id;           // nunca muda após construção
    private final List<Item> items;  // referência fixa, embora conteudo possa alterar
    // ...
}
```

Nesse caso, `id` e `items` são definidos uma única vez no construtor. O uso de `final` deixa claro que não haverá reatribuição: é uma prática recomendada. Caso seja necessário reatribuir um campo (por exemplo, para Cachinglazy ou campos `static` mutáveis intencionais), então *não* se usa `final`. Mas, em geral, **usar `final` em campos é encorajado**: simplifica o entendimento e evita erros de substituição acidental.

> **Diretriz:** Tornar campos finais sempre que não forem reatribuídos. Esse padrão aprimora a imutabilidade da classe e ajuda em segurança de thread.

*** ## 3. `final` em variáveis locais

O uso de `final` em **variáveis locais** (declaradas dentro de métodos) é mais controverso e depende do estilo da equipe. Variáveis locais são de curto escopo e seu ciclo de vida termina ao sair do método. Ainda assim, algumas convenções preveem marcá-las como `final` para enfatizar que aquela variável não muda de valor após ser inicializada naquele bloco de código.

**Vantagens:** Em métodos complexos com vários fluxos condicionais, declarar uma variável local `final` pode evidenciar que ela recebe valor exatamente uma vez. Isso funciona como um lembrete de que ela age como “uma constante local” dentro daquele método. Por exemplo:

```java
public void process(int status) {
    final String message;
    if (status == 200) {
        message = "OK";
    } else {
        message = "FAIL";
    }
    // A partir daqui, message jamais muda
    System.out.println(message);
}
```

Nesse código, o `final` em `message` demonstra ao leitor que **toda rota de execução atribui um valor a `message` e não haverá reatribuição posterior**. Isso pode evitar erros de lógica (como esquecer de inicializar em algum ramo) e documenta claramente a intenção.

**Desvantagens:** Em métodos mais simples ou ao declarar muitas variáveis finais sem necessidade, o código pode ficar verboso e menos legível. Muitos guias sugerem que, a menos que haja motivo real para fixar a variável, pode-se omitir `final` em locais públicos ou sem importância especial, pois o compilador já controlará eventuais reatribuições incorretas. Em suma, não há regra rígida: “usar ou não final em locais depende do contexto”. Geralmente:

-* Para métodos **curtos e simples**, frequentemente se omite `final` em locais, mantendo o foco na lógica principal.
-* Em métodos **complexos**, usar `final` em alguns locais pode ajudar a reduzir acidentalidades e documentar melhor as intenções.

> **Diretriz:** Avalie cada caso. Marque como `final` variáveis locais quando isso ajudar a esclarecer a lógica (especialmente em métodos não triviais), mas não abuse para não encher o código de palavras-chave desnecessárias.

*** ## 4. `final` em parâmetros de método

Marcando parâmetros com `final` impede sua reatribuição dentro do corpo do método. No entanto, reatribuir parâmetros já é considerado **mau estilo** em Java por si só, pois parametros representam inputs ao método e devem ser tratados como valores fixos de entrada. Consequentemente, muitos especialistas e guias de estilo recomendam **não usar `final` em parâmetros**, exceto quando requerido por convenção da equipe. Conforme aponta um guia prático: *“não use `final` para parâmetros de método, a não ser que o projeto siga essa convenção”*.

Na prática moderna, o Eclipse e o compilador Java já emitem avisos se você tentar atribuir novo valor a um parâmetro (por exemplo, `param = x;` é sinalizado como “pode confundir”). Adicionar `final` ao parâmetro não traz benefício funcional (o compilador já garante que não seja reatribuído) e só aumenta visualmente a assinatura do método. Assim, em código de produção costuma-se deixá-los sem `final`.

**Exemplo (não recomendado):**

```java
public void salvar(final String nome, final List<Long> ids) {
    // Uso redundante: nome e ids não devem ser reatribuídos internamente
    System.out.println(nome);
}
```

Aqui, o `final` não impede nada além de deixar o código mais verboso. Muitos desenvolvedores preferem simplesmente não reatribuir `nome` ou `ids` e confiar na revisão de código para evitar mudanças indevidas. Em resumo, o consenso é **não marcar parâmetros como final** por padrão.

> **Diretriz:** Usar `final` em parâmetros raramente é necessário. Prefira parâmetros não finais para não poluir a assinatura do método. Se a política de projeto exigir consistência (ou se você estiver migrando código que exige isso), você pode usar; caso contrário, não é prática comum.

*** ## 5. Exemplos práticos com listas e DTOs

Considere o caso de uma **lista mutável** e um **DTO** (objeto de transferência de dados, presumivelmente mutável). Veja os exemplos abaixo:

```java
// Exemplo 1: final em uma lista mutável
final List<Long> numeros = new ArrayList<>();
numeros.add(42L);      // Válido: modifica o conteúdo da lista
// numeros = new ArrayList<>(); // Erro de compilação: não se pode reatribuir a referência final

// Exemplo 2: final em um DTO mutável
final RectangleDto rect = new RectangleDto(10, 20);
rect.setWidth(15);     // Válido: altera o estado interno de rect
// rect = new RectangleDto(5, 5); // Erro de compilação: referência final não muda
```

Em ambos os exemplos, o modificador `final` impede apenas a reatribuição da variável (as linhas comentadas gerariam erro). **Não impede mutações internas** do objeto. É um equívoco comum pensar que `final List` ou `final RectangleDto` tornará a lista ou o DTO imutável – na verdade, o objeto em si continua livre para mudanças. Para garantir imutabilidade real, seria necessário usar coleções imutáveis (como `List.copyOf(...)`) ou objetos que propriamente implementem o padrão *immutable*. O `final` apenas assegura que, uma vez associado um objeto à variável, ela não apontará para outro objeto diferente.

> **Conclusão:** Use `final` em listas e DTOs para indicar que a variável não será reatribuída, mas tenha em mente que isso **não transforma** o objeto em imutável. O estado interno do objeto ainda pode mudar.

*** ## 6. Código de produção vs código de teste

Na prática, **não há regras formais distintas** para o uso de `final` em código de produção versus código de teste. Geralmente, as convenções adotadas pelo time são aplicadas igualmente. Alguns desenvolvedores podem optar por usar menos `final` em classes de teste para manter os testes mais concisos, já que testes não costumam ter problema de *thread-safety* ou publicação segura de dados. Porém, se o projeto definir que *tudo deve ser final quando possível*, esse padrão se estende também aos testes. De forma geral, **guia de estilo oficiais (como o Google Java Style)** não diferenciam código-fonte e testes neste aspecto; ou seja, aplica-se o mesmo bom senso.

Em resumo, o que vale para a base de código vale para os testes: manter consistência com o padrão do time. Se a equipe decidir marcar variáveis de teste como final (por exemplo, para clareza em casos complexos), tudo bem. Se decidir omitir, também não há problema formal. O importante é seguir a convenção local e focar na legibilidade e manutenção do teste.

*** ## 7. Impacto na manutenção e suporte das IDEs

Marcar variáveis como `final` pode facilitar a **manutenção** do código, pois evidencia a imutabilidade da referência e ajuda a evitar reatribuições acidentais. Alguns desenvolvedores observam que isso reduz a carga cognitiva ao ler código longo. Além disso, campos `final` bem usados tornam mais fácil garantir a *segurança de publicação* em ambiente concorrente (por exemplo, uma vez atribuído no construtor, o campo final sempre será visível corretamente em outras threads).

Por outro lado, uso exagerado de `final` também gera poluição visual, como mencionado antes, e às vezes causa quebras de linha indesejadas, comprometendo a estética do código. Portanto, o impacto em manutenção varia conforme a cultura da equipe: há quem veja como prática benéfica e quem ache supérfluo.

Em relação às **ferramentas de desenvolvimento**, as IDEs oferecem suporte a esse estilo. No IntelliJ IDEA, há uma inspeção (“Local variable or parameter can be `final`”) que sinaliza automaticamente variáveis locais e parâmetros que poderiam receber o modificador. Isso auxilia a manter o padrão escolhido pelo time, permitindo até aplicar *quick-fixes* para adicionar `final` onde cabível. O Eclipse também possui opções de **Save Actions** que podem inserir o `final` em variáveis locais/parameters automaticamente. Ferramentas de análise estática (Checkstyle, PMD, SonarQube etc.) podem igualmente ser configuradas para sugerir ou exigir `final` em variáveis que não são reatribuídas.

> **Resumo:** O uso de `final` pode ajudar na legibilidade e segurança do código (ao evitar reatribuições indesejadas) e as IDEs modernas suportam isso com inspeções automáticas. Todavia, seu uso deve ser avaliado em conjunto com a clareza do código, pois muitos `final` podem atrapalhar a leitura.

